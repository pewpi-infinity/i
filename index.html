<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Octave OS — Single-file Project Bundle (embedded files + in-script logging)</title>
  <style>
    :root{
      --bg:#f0fbff;
      --term-bg:#032a31;
      --term-text:#c7f3ff;
      --typed:#1b78b8;
      --panel:#ffffff;
      --muted:#45666a;
      --noun:#f2d024; --verb:#2fb86a; --adj:#4fb8e0; --adv:#ff9a3c; --num:#c66eff; --other:#e14b4b;
      --token-bg:#eaf9ff; --token-text:#045d74;
      --active: rgba(27,120,184,0.14);
    }
    html,body{height:100%;margin:0}
    body{font-family:system-ui,-apple-system,Roboto,Arial;background:var(--bg);color:#04282f;padding:14px}
    .wrap{max-width:1180px;margin:0 auto}
    .header{background:var(--term-bg);color:var(--term-text);padding:12px;border-radius:8px;font-family:monospace}
    .header h1{margin:0;color:var(--typed);font-size:18px}
    .card{background:var(--panel);border-radius:8px;padding:12px;margin-top:12px;border:1px solid #e0eef0}
    .controls{display:flex;gap:8px;align-items:center}
    .mode-btn{padding:8px 12px;border-radius:8px;border:1px solid #dfeff2;background:#fff;cursor:pointer;color:#04323a}
    .mode-btn.active{outline:4px solid var(--active);box-shadow:0 6px 18px rgba(5,40,48,0.08);font-weight:700}
    .wallet-badge{background:var(--token-bg);padding:6px 10px;border-radius:8px;color:var(--token-text);font-weight:700;border:1px solid #cbeff8}
    .panel{background:var(--term-bg);color:var(--term-text);min-height:420px;border-radius:6px;padding:12px;overflow:auto;white-space:pre-wrap;font-family:monospace}
    .input-row{display:flex;gap:8px;margin-top:8px;align-items:center}
    .input-line{flex:1;padding:10px;border-radius:8px;border:1px solid #cfe8ef;font-size:15px}
    .small{font-size:13px;color:var(--muted)}
    .list{background:#fff;border-radius:6px;padding:6px;margin-top:8px;max-height:280px;overflow:auto;border:1px solid #e6eef0}
    .list .item{padding:8px;border-bottom:1px dashed #eef6f8;cursor:pointer}
    .list .item:hover{background:#f6fbfb}
    .pos-noun{color:var(--noun);font-weight:700}
    .pos-verb{color:var(--verb);font-weight:700}
    .pos-adj{color:var(--adj)}
    .pos-adv{color:var(--adv)}
    .pos-num{color:var(--num);font-weight:700}
    .pos-other{color:var(--other)}
    .danger{color:#b00020;font-weight:700}
    pre.embedded { background:#0b2b33;color:#d6f3fb;padding:10px;border-radius:6px;overflow:auto;max-height:240px; }
    .tiny { font-size:12px;color:#7a98a0; }
    .sr-only{position:absolute;left:-10000px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <h1>∞ Octave Terminal — Single-file Project Bundle</h1>
    </div>

    <div class="card" id="app">
      <div class="controls" style="margin-bottom:10px;">
        <button id="btnConversation" class="mode-btn active">Conversation</button>
        <button id="btnSecret" class="mode-btn">Secret message</button>
        <div style="flex:1"></div>
        <div class="small">Wallet:</div>
        <div id="walletBadge" class="wallet-badge">(none)</div>
      </div>

      <div id="terminal" class="panel" role="log" aria-live="polite"></div>

      <div class="input-row">
        <input id="inputLine" class="input-line" placeholder="Type /help for commands or type message. Enter to send." />
        <button id="sendBtn" class="mode-btn">Send</button>
      </div>

      <div style="margin-top:12px" class="small">Everything stored will be appended into the embedded store below and also appended to the in-file log.txt content. Use <code>/export html</code> to copy the full updated HTML (paste into your repo to persist).</div>

      <div style="margin-top:12px">
        <div class="small">Entries (click to open or decrypt):</div>
        <div id="entryList" class="list"></div>
      </div>

      <div style="margin-top:12px">
        <div class="small">In-file log (log.txt equivalent) preview (keeps full conversation history inside the file):</div>
        <pre id="logPreview" class="embedded tiny">(log is empty)</pre>
      </div>
    </div>
  </div>

  <!-- ================================================================
       EMBEDDED CANONICAL STORE: This is the canonical in-file storage.
       items:
         - meta: metadata incl current_user
         - wallets: users and tokens
         - entries: each stored item (user/ai/encoded/log)
         - log_txt: a text blob representing logs/txt.log (appended on each stored action)
         - embedded_files: raw source copies of repo files (so the whole repo is in one HTML)
     ================================================================ -->
  <script id="repo_data" type="application/json">
{
  "meta": {
    "created_by": "single-file-bundle",
    "created_at": "2025-11-17T07:01:51Z",
    "current_user": ""
  },
  "wallets": {},
  "entries": [],
  "log_txt": "",
  "embedded_files": {}
}
  </script>

  <!-- =========================
       EMBEDDED FILES (raw)
       Each file from the repo is included below inside a <script type="text/plain" data-path="..."> block.
       When you export/save the full HTML, these blocks will be preserved and therefore the repository files
       are available inside the single index.html file.
       =================================================================== -->

  <script type="text/plain" data-path="static/js/commit-client.js">
/**
 * static/js/commit-client.js
 *
 * Small client helper to POST typed text to the server commit endpoint.
 * Usage:
 *   CommitClient.send("your text")
 *     .then(resp => console.log('committed', resp))
 *     .catch(err => console.error(err));
 *
 * IMPORTANT:
 * - Do NOT store GitHub tokens in client code.
 * - For simple setups you can set window.COMMIT_SECRET from server-rendered HTML to provide the secret.
 */
const CommitClient = (function () {
  const ENDPOINT = '/commit';
  const SECRET = window.COMMIT_SECRET || null;

  async function send(text) {
    if (!text || !text.trim()) throw new Error('text required');

    const payload = { text: text };
    const headers = { 'Content-Type': 'application/json' };
    if (SECRET) headers['X-Commit-Secret'] = SECRET;

    const resp = await fetch(ENDPOINT, {
      method: 'POST',
      headers,
      body: JSON.stringify(payload),
      credentials: 'same-origin'
    });
    if (!resp.ok) {
      const body = await resp.json().catch(() => ({}));
      throw new Error(body && body.error ? body.error : `HTTP ${resp.status}`);
    }
    return resp.json();
  }

  return { send };
})();
window.CommitClient = CommitClient;
  </script>

  <script type="text/plain" data-path="logger.py">
#!/usr/bin/env python3
"""
logger.py — safe, minimal logging helper for Octave OS.

Usage:
  from logger import append_log, commit_log

Design:
- Appends timestamped entries to logs/txt.log
- Use append_log(text, kind="IN"|"OUT"|"INFO") to record messages.
- Optional auto-commit: set environment variable OCTAVE_AUTO_COMMIT="1"
  and (optionally) OCTAVE_AUTO_PUSH="1" to push after commit.
  The process that runs commits must have git credentials configured (SSH key
  or credential helper). Do NOT put tokens into files.

Security note:
- Never store secrets (tokens) inside repository files. Use environment variables,
  CI secrets, or an already-configured git credential helper/SSH key for commits.
"""
import os
from datetime import datetime
import subprocess
from typing import Tuple

ROOT = os.path.abspath(os.path.dirname(__file__))
LOG_DIR = os.path.join(ROOT, "logs")
LOG_FILE = os.path.join(LOG_DIR, "txt.log")

os.makedirs(LOG_DIR, exist_ok=True)

def _timestamp() -> str:
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3] + " UTC"

def append_log(text: str, kind: str = "INFO") -> str:
    """
    Append a timestamped log entry to logs/txt.log.
    kind: "IN" (user), "OUT" (bot), "INFO" (misc).
    Returns the path of the log file written.
    """
    if text is None:
        text = ""
    # Normalize kind
    kind = (kind or "INFO").upper()
    entry = f"[{_timestamp()}] [{kind}] {text}\n"
    with open(LOG_FILE, "a", encoding="utf-8") as f:
        f.write(entry)
    return LOG_FILE

def commit_log(commit_message: str = None, push: bool = False) -> Tuple[bool, str]:
    """
    Optional: git add/commit (and optionally push) the logs file.
    Controlled by calling process and environment. Use with caution.
    Returns tuple (ok, output).
    Preconditions:
      - This script runs from the repository root (or git operations will fail).
      - Git must be available and credentials configured in the environment.
    """
    commit_message = commit_message or f"Auto log update: {_timestamp()}"
    try:
        # Add the log file
        subprocess.check_output(["git", "add", LOG_FILE], stderr=subprocess.STDOUT)
        subprocess.check_output(["git", "commit", "-m", commit_message], stderr=subprocess.STDOUT)
        out = "committed"
        if push:
            subprocess.check_output(["git", "push"], stderr=subprocess.STDOUT)
            out += " and pushed"
        return True, out
    except subprocess.CalledProcessError as e:
        return False, e.output.decode(errors="replace")
    except FileNotFoundError:
        return False, "git not found in PATH"
  </script>

  <script type="text/plain" data-path="log_server.py">
#!/usr/bin/env python3
"""
Minimal HTTP logger service. Place in repo root and run:
  pip install flask flask-cors
  python3 log_server.py

The web UI can POST {"text":"..."} to /log and this server will append to logs/txt.log.
"""
import os
from datetime import datetime
from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS

ROOT_DIR = os.path.abspath(os.path.dirname(__file__))
LOG_DIR = os.path.join(ROOT_DIR, "logs")
LOG_FILE = os.path.join(LOG_DIR, "txt.log")
os.makedirs(LOG_DIR, exist_ok=True)

app = Flask(__name__, static_folder=ROOT_DIR, static_url_path='')
CORS(app)

def ts():
    return datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3] + " UTC"

@app.route("/")
def index():
    return send_from_directory(ROOT_DIR, "index.html")

@app.route("/log", methods=["POST"])
def log():
    data = request.get_json(silent=True) or {}
    text = data.get("text", "")
    kind = data.get("kind", "IN")
    entry = f"[{ts()}] [{kind}] {text}\n"
    try:
        with open(LOG_FILE, "a", encoding="utf-8") as f:
            f.write(entry)
        return jsonify(status="ok")
    except Exception as e:
        return jsonify(status="error", message=str(e)), 500

if __name__ == "__main__":
    app.run(host="127.0.0.1", port=5050)
  </script>

  <script type="text/plain" data-path="encode_local.py">
#!/usr/bin/env python3
"""
Local encoder / decoder that matches the in-page Pewpi encoder (PBKDF2 -> AES-GCM).

Usage (local machine only):
  1) pip install cryptography
  2) python encode_local.py

This script:
 - prompts you to enter text (hidden) to encode or decode
 - produces a single base64 string: salt(16) + iv(12) + ciphertext
 - can write server/.env locally with GITHUB_TOKEN_B64=<encoded> if you choose (DO NOT commit)

Security: run this locally on your machine. Do not paste raw secrets into public pages or commit them.
"""
import base64
import getpass
import os
from pathlib import Path
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.backends import default_backend
import secrets

def derive_key(passphrase: bytes, salt: bytes, iterations: int = 200000) -> bytes:
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=iterations,
        backend=default_backend()
    )
    return kdf.derive(passphrase)

def encrypt(plaintext: bytes, passphrase: str, iterations: int = 200000) -> str:
    salt = secrets.token_bytes(16)
    iv = secrets.token_bytes(12)
    key = derive_key(passphrase.encode('utf-8'), salt, iterations)
    aesgcm = AESGCM(key)
    ct = aesgcm.encrypt(iv, plaintext, None)
    combined = salt + iv + ct
    return base64.b64encode(combined).decode('ascii')

def decrypt(encoded_b64: str, passphrase: str, iterations: int = 200000) -> bytes:
    combined = base64.b64decode(encoded_b64)
    if len(combined) < 16+12+16:
        raise ValueError("Input too short or invalid")
    salt = combined[:16]
    iv = combined[16:28]
    ct = combined[28:]
    key = derive_key(passphrase.encode('utf-8'), salt, iterations)
    aesgcm = AESGCM(key)
    return aesgcm.decrypt(iv, ct, None)

def main():
    print("Pewpi local encoder/decoder (runs locally). Do not commit outputs with raw secrets.")
    mode = input("Choose (e)ncode or (d)ecrypt: ").strip().lower()
    iters_input = input("PBKDF2 iterations (enter to keep 200000): ").strip()
    iterations = int(iters_input) if iters_input.isdigit() else 200000

    if mode == 'e':
        secret = getpass.getpass("Enter text to encode (input hidden): ")
        if not secret:
            print("No input, aborting.")
            return
        encoded = encrypt(secret.encode('utf-8'), getpass.getpass("Passphrase (hidden): "), iterations)
        print("\nENCODED OUTPUT (base64):\n")
        print(encoded)
        choice = input("\nWrite to server/.env as GITHUB_TOKEN_B64? (y/N): ").strip().lower()
        if choice == 'y':
            server_dir = Path('server'); server_dir.mkdir(exist_ok=True)
            env_path = server_dir / '.env'
            if env_path.exists():
                if input("server/.env exists — overwrite? (y/N): ").strip().lower() != 'y':
                    print("Aborted writing file.")
                    return
            env_contents = f"GITHUB_TOKEN_B64={encoded}\n# set COMMIT_SECRET locally\n# COMMIT_SECRET=your_secret_here\nPORT=4000\n"
            env_path.write_text(env_contents, encoding='utf-8')
            print(f"Wrote {env_path.resolve()} (do NOT commit it).")
    elif mode == 'd':
        encoded = input("Paste encoded base64 string: ").strip()
        if not encoded:
            print("No input, aborting.")
            return
        passphrase = getpass.getpass("Passphrase to decrypt (hidden): ")
        try:
            plaintext = decrypt(encoded, passphrase, iterations)
            print("\nDECRYPTED TEXT:\n")
            print(plaintext.decode('utf-8'))
        except Exception as e:
            print("Decryption failed:", str(e))
    else:
        print("Invalid option. Run again.")

if __name__ == '__main__':
    main()
  </script>

  <script type="text/plain" data-path="encode_pat.py">
#!/usr/bin/env python3
# Local helper: base64-encode your PAT and write server/.env (local only).
# Run this on your machine where you will run the commit server.
#
# Usage:
#   python encode_pat.py
#
# It will prompt for:
# - GitHub PAT (input is hidden)
# - COMMIT_SECRET (the short secret you will paste into the page session)
#
# The script writes server/.env with GITHUB_TOKEN_B64=... and COMMIT_SECRET=...
# DO NOT commit server/.env to git.

import os
import base64
import getpass
from pathlib import Path

def main():
    print("This creates server/.env locally. Do NOT commit server/.env to the repository.")
    pat = getpass.getpass("Enter your GitHub Personal Access Token (input hidden): ").strip()
    if not pat:
        print("No token provided, aborting.")
        return
    secret = getpass.getpass("Enter a short COMMIT_SECRET (you will paste into the page for this session): ").strip()
    if not secret:
        print("No secret provided, aborting.")
        return

    b64 = base64.b64encode(pat.encode('utf-8')).decode('ascii')
    env_lines = [
        f"GITHUB_TOKEN_B64={b64}",
        f"COMMIT_SECRET={secret}",
        "PORT=4000",
    ]
    server_dir = Path('server')
    server_dir.mkdir(exist_ok=True)
    env_path = server_dir / '.env'
    if env_path.exists():
        confirm = input(f"server/.env already exists. Overwrite? (y/N): ").strip().lower()
        if confirm != 'y':
            print("Aborted.")
            return

    env_path.write_text("\n".join(env_lines) + "\n", encoding='utf-8')
    print(f"Wrote {env_path.resolve()} (do NOT commit it).")
    print("Now start your server (see server/log_commit_server.py) — server will decode the token from GITHUB_TOKEN_B64 at runtime.")

if __name__ == '__main__':
    main()
  </script>

  <script type="text/plain" data-path="octave_os.py">
# ================================================
#   OCTAVE OS v0.12 (FIXED)
#   Kernel + Shell + AI-Ready Knowledge Vault
#   Author: Kris Watson
# ================================================
# (blueprint archive and DATA_CHAMBER trimmed for embedding but included in actual repo copy)
# Full file available in original repo; embedded here as snapshot for reference.
# ... (content truncated here for brevity in this embedded block; full original included in repo)
  </script>

  <script type="text/plain" data-path="run_octave_logged.py">
#!/usr/bin/env python3
"""
Run Octave OS but log every incoming and outgoing message to logs/txt.log using logger.append_log.
This is a wrapper so we don't need to modify octave_os.py directly.
"""
# (script content embedded for reference; full original kept in repository)
  </script>

  <script type="text/plain" data-path=".gitignore">
# top-level ignores
node_modules/
.env
server/.env
__pycache__/
*.pyc
.vscode/
.idea/
.DS_Store
  </script>

  <!-- ===========================
       END embedded raw files
       =========================== -->

  <script>
  // Main single-file app logic that appends to in-file log_txt and updates embedded store files.
  (function(){
    const repoEl = document.getElementById('repo_data');

    function loadRepo(){ try { return JSON.parse(repoEl.textContent || repoEl.innerText); } catch(e){ return { meta:{}, wallets:{}, entries:[], log_txt:'', embedded_files:{} }; } }
    function saveRepo(obj){ repoEl.textContent = JSON.stringify(obj, null, 2); renderAll(); }

    function nowIso(){ return new Date().toISOString(); }
    function uid(){ return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,8); }

    // Append a line to in-file log_txt (acts as logs/txt.log inside the HTML)
    function appendLogText(kind, text){
      const d = loadRepo();
      d.log_txt = (d.log_txt || '') + `[${nowIso()}] [${kind}] ${text}\n`;
      saveRepo(d);
    }

    // Append an entry object to entries and write a log line
    function appendEntry(obj){
      const d = loadRepo();
      d.entries = d.entries || [];
      d.entries.push(obj);
      appendLogText('IN', `${obj.type} ${obj.id} ${obj.summary || obj.text || ''}`);
      saveRepo(d);
    }

    // Render functions
    const terminal = document.getElementById('terminal');
    const entryList = document.getElementById('entryList');
    const logPreview = document.getElementById('logPreview');
    const walletBadge = document.getElementById('walletBadge');

    function renderAll(){
      renderTerminal();
      renderList();
      renderLogPreview();
      renderWallet();
    }

    function renderTerminal(){
      const d = loadRepo();
      terminal.innerHTML = '';
      (d.entries || []).forEach(e => {
        const line = `[${e.timestamp}] (${e.type}) ${e.type==='encoded' ? '(encoded) ' + e.id : (e.summary || e.text || e.id)}`;
        const div = document.createElement('div');
        div.textContent = line;
        terminal.appendChild(div);
      });
      terminal.scrollTop = terminal.scrollHeight;
    }

    function renderList(){
      const d = loadRepo();
      entryList.innerHTML = '';
      const arr = (d.entries || []).slice().reverse();
      if(arr.length === 0){ entryList.innerHTML = '<div class="small">(no entries)</div>'; return; }
      arr.forEach(e => {
        const div = document.createElement('div');
        div.className = 'item';
        div.innerHTML = `<div style="font-weight:700">${e.id} &nbsp; <small>${e.type}</small></div><div class="small">${e.timestamp}</div>`;
        div.addEventListener('click', ()=>openEntry(e.id));
        entryList.appendChild(div);
      });
    }

    function renderLogPreview(){
      const d = loadRepo();
      const text = d.log_txt || '(log is empty)';
      logPreview.textContent = text;
    }

    function renderWallet(){
      const d = loadRepo();
      walletBadge.textContent = (d.meta && d.meta.current_user) || '(none)';
    }

    async function openEntry(id){
      const d = loadRepo();
      const e = (d.entries || []).find(x => x.id === id);
      if(!e){ alert('entry not found'); return; }
      if(e.type === 'encoded'){
        const pass = prompt('Enter passphrase to decrypt (local only):');
        if(!pass) return;
        try{
          const plain = await decryptText(e.cipher, pass);
          alert('DECRYPTED:\\n\\n' + plain);
        } catch(err){
          alert('Decrypt failed: ' + (err.message || err));
        }
      } else {
        alert(`${e.type.toUpperCase()}\\n\\n${e.summary || e.text || ''}`);
      }
    }

    // token utilities (simple)
    function ensureWallet(id){
      const d = loadRepo();
      d.wallets = d.wallets || {};
      if(!d.wallets[id]) d.wallets[id] = { id:id, balance:0, last_awarded:0, tokens:[] };
      saveRepo(d);
    }
    function genTokenCode(){ const t = Date.now().toString(36).toUpperCase(); const r = Math.floor(Math.random()*900000 + 100000).toString(36).toUpperCase(); return `${t}-${r}`; }
    function awardTokenToUser(username, entryId){
      const d = loadRepo(); d.wallets = d.wallets || {}; if(!d.wallets[username]) d.wallets[username] = { id:username, balance:0, last_awarded:0, tokens:[] };
      const w = d.wallets[username];
      const now = Date.now(); const elapsed = now - (w.last_awarded || 0); const COOLDOWN = 30*60*1000;
      if(elapsed >= COOLDOWN){
        const code = genTokenCode();
        const tok = { code: code, issued_at: new Date(now).toISOString(), entry_id: entryId, spent: false };
        w.tokens.push(tok); w.balance = (w.balance||0) + 1; w.last_awarded = now; saveRepo(d);
        appendLogText('INFO', `Token issued ${code} to ${username} for ${entryId||'(none)'}`);
        return { awarded:true, code, balance:w.balance };
      } else {
        return { awarded:false, cooldown_remaining: Math.ceil((COOLDOWN - elapsed)/1000), balance:w.balance||0 };
      }
    }
    function spendToken(username, code, entryId){
      const d = loadRepo();
      const w = (d.wallets && d.wallets[username]) || null;
      if(!w) return { ok:false, error:'no wallet' };
      const tok = (w.tokens||[]).find(t=>t.code === code);
      if(!tok) return { ok:false, error:'not found' };
      if(tok.spent) return { ok:false, error:'already spent' };
      tok.spent = true; tok.spent_at = new Date().toISOString(); tok.spent_for = entryId || null; w.balance = Math.max(0, (w.balance||0) - 1); saveRepo(d);
      appendLogText('INFO', `Token spent ${code} by ${username} for ${entryId||'(none)'}`);
      return { ok:true, balance:w.balance };
    }

    // Input processing: terminal commands and message handling
    async function processLine(raw){
      const line = (raw||'').trim(); if(!line) return;
      if(line.startsWith('/')){
        const parts = line.split(/\s+/);
        const cmd = parts[0].toLowerCase();
        if(cmd === '/help'){ appendToTerminal('Commands: /help /login <id> /whoami /list /open <id> /spend <code> [entry] /export html /export b64'); return; }
        if(cmd === '/login'){ const id = parts[1]; if(!id){ appendToTerminal('Usage: /login <id>'); return; } const d = loadRepo(); d.meta = d.meta || {}; d.meta.current_user = id; saveRepo(d); ensureWallet(id); appendToTerminal('Logged in: '+id); return; }
        if(cmd === '/whoami'){ appendToTerminal('User: ' + ((loadRepo().meta && loadRepo().meta.current_user) || '(none)')); return; }
        if(cmd === '/list'){ const arr = (loadRepo().entries||[]).map(e=>`${e.id} ${e.type} ${e.timestamp}`); appendToTerminal('Entries:\\n' + arr.join('\\n')); return; }
        if(cmd === '/open'){ const id = parts[1]; if(!id){ appendToTerminal('Usage: /open <id>'); return; } openEntry(id); return; }
        if(cmd === '/spend'){ const code = parts[1]; const eId = parts[2]||null; if(!code){ appendToTerminal('Usage: /spend <code> [entryId]'); return; } const cur = (loadRepo().meta && loadRepo().meta.current_user); if(!cur){ appendToTerminal('Login first'); return; } const r = spendToken(cur, code, eId); appendToTerminal(r.ok ? 'Spent. Balance:'+r.balance : 'Spend failed:'+r.error); return; }
        if(cmd === '/export' && parts[1] === 'html'){ const snap = buildSnapshotHtml(); try{ await navigator.clipboard.writeText(snap); appendToTerminal('Full HTML copied to clipboard. Paste into repo to persist.'); }catch(e){ appendToTerminal('Copy failed; download started.'); } const blob=new Blob([snap],{type:'text/html'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='index_snapshot.html'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); return; }
        if(cmd === '/export' && parts[1] === 'b64'){ const snap = buildSnapshotHtml(); const b64 = b64EncodeUnicode(snap).replace(/\n/g,''); try{ await navigator.clipboard.writeText(b64); appendToTerminal('Base64 snapshot copied to clipboard.'); }catch(e){ appendToTerminal('Copy failed; download started.'); const blob=new Blob([b64]); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='snapshot.b64'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); } return; }
        appendToTerminal('Unknown command: ' + cmd); return;
      }

      const secretMode = document.getElementById('btnSecret').classList.contains('active');
      if(secretMode){
        const pass = prompt('Passphrase to encrypt this secret (will NOT be stored unless you embed it):');
        if(!pass){ appendToTerminal('Encrypt aborted'); return; }
        try{
          const cipher = await encryptText(line, pass);
          const e = { id: uid(), type:'encoded', cipher: cipher, timestamp: nowIso() };
          appendEntry(e);
          appendToTerminal('Secret stored: ' + e.id);
          const cur = (loadRepo().meta && loadRepo().meta.current_user);
          if(cur){ const aw = awardTokenToUser(cur, e.id); appendToTerminal(aw.awarded ? ('Token: '+aw.code+' balance:'+aw.balance) : ('Not awarded (cooldown) balance:'+aw.balance)); }
        }catch(err){ appendToTerminal('Encrypt failed: '+(err.message||err)); }
      } else {
        appendEntry({ id: uid(), type:'user', text: line, timestamp: nowIso() });
        const digest = line.split(/\s+/).slice(0,40).join(' ');
        appendEntry({ id: uid(), type:'ai', summary: 'Octave distilled: '+digest, timestamp: nowIso() });
        appendToTerminal('Conversation stored (digest).');
        const cur = (loadRepo().meta && loadRepo().meta.current_user);
        if(cur){ const aw = awardTokenToUser(cur, null); appendToTerminal(aw.awarded ? ('Token: '+aw.code+' balance:'+aw.balance) : ('Not awarded (cooldown) balance:'+aw.balance)); }
      }
    }

    function appendToTerminal(s){
      const div = document.createElement('div');
      div.textContent = s;
      terminal.appendChild(div);
      terminal.scrollTop = terminal.scrollHeight;
      renderList(); renderLogPreview(); renderWallet();
    }

    function buildSnapshotHtml(){
      const clone = document.documentElement.cloneNode(true);
      const repo = clone.querySelector('#repo_data');
      if(repo) repo.textContent = JSON.stringify(loadRepo(), null, 2);
      else {
        const s = clone.ownerDocument.createElement('script');
        s.id = 'repo_data'; s.type = 'application/json'; s.textContent = JSON.stringify(loadRepo(), null, 2);
        clone.querySelector('body').appendChild(s);
      }
      // preserve embedded raw file blocks: copy innerText of each original embedded script[type="text/plain"][data-path]
      const originalBlocks = document.querySelectorAll('script[type="text/plain"][data-path]');
      originalBlocks.forEach(block=>{
        const path = block.getAttribute('data-path');
        const node = clone.querySelector(`script[type="text/plain"][data-path="${path}"]`);
        if(!node){
          const newNode = clone.ownerDocument.createElement('script');
          newNode.setAttribute('type','text/plain');
          newNode.setAttribute('data-path', path);
          newNode.textContent = block.textContent || '';
          clone.querySelector('body').appendChild(newNode);
        } else {
          node.textContent = block.textContent || '';
        }
      });
      return '<!doctype html>\\n' + clone.outerHTML;
    }

    // Wire UI
    document.getElementById('btnConversation').addEventListener('click', ()=>{ document.getElementById('btnConversation').classList.add('active'); document.getElementById('btnSecret').classList.remove('active'); appendToTerminal('Mode: Conversation'); });
    document.getElementById('btnSecret').addEventListener('click', ()=>{ document.getElementById('btnSecret').classList.add('active'); document.getElementById('btnConversation').classList.remove('active'); appendToTerminal('Mode: Secret'); });
    document.getElementById('sendBtn').addEventListener('click', ()=>{ const v=document.getElementById('inputLine').value; processLine(v); document.getElementById('inputLine').value=''; });
    document.getElementById('inputLine').addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); const v=document.getElementById('inputLine').value; processLine(v); document.getElementById('inputLine').value=''; } });

    // initialize
    renderAll();
    appendToTerminal('Single-file bundle ready. Type /help for commands. All logs are appended to in-file log_txt and entries.');
    // Expose functions for debugging
    window.SINGLE_BUNDLE = { loadRepo, saveRepo, appendEntry, buildSnapshotHtml, appendLogText, awardTokenToUser, spendToken };
  })();
  </script>

</body>
</html>