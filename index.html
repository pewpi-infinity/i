<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Octave OS — Terminal-first Embedded Store</title>
  <style>
    :root{
      --bg:#edf6f8;
      --term-bg:#04282f;
      --term-text:#c7f3ff;
      --typed:#1e78b8;
      --panel:#ffffff;
      --muted:#5f7a82;
      --noun:#f2d024; --verb:#2fb86a; --adj:#4fb8e0; --adv:#ff9a3c; --num:#c66eff; --other:#e14b4b;
      --token-bg:#eaf9ff; --token-text:#045d74;
    }
    html,body{height:100%;margin:0}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:#04282f;padding:14px}
    .terminal-wrap{max-width:1100px;margin:0 auto}
    .terminal-header{background:var(--term-bg);color:var(--term-text);padding:14px;border-radius:8px;font-family:monospace}
    .terminal-header h1{margin:0;color:var(--typed);font-size:18px}
    /* Minimal UI: terminal only area, two mode buttons and small wallet display */
    .controls{display:flex;gap:8px;margin-top:10px;align-items:center}
    .mode-btn{padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.02);color:var(--term-text);cursor:pointer}
    .mode-btn.active{box-shadow:0 4px 10px rgba(0,0,0,0.2);outline:3px solid rgba(30,120,184,0.15)}
    .wallet-badge{background:var(--token-bg);padding:6px 10px;border-radius:8px;color:var(--token-text);font-weight:700;border:1px solid #c9eef8}
    .card{background:var(--panel);border-radius:8px;padding:12px;margin-top:12px;border:1px solid #e2eef0}
    .panel{background:var(--term-bg);color:var(--term-text);min-height:420px;border-radius:6px;padding:12px;overflow:auto;white-space:pre-wrap;font-family:monospace}
    .input-row{display:flex;gap:8px;margin-top:8px;align-items:center}
    .input-line{flex:1;padding:10px;border-radius:8px;border:1px solid #d6e9ef;font-size:15px}
    .small{font-size:13px;color:var(--muted)}
    .pos-noun{color:var(--noun);font-weight:700}
    .pos-verb{color:var(--verb);font-weight:700}
    .pos-adj{color:var(--adj)}
    .pos-adv{color:var(--adv)}
    .pos-num{color:var(--num);font-weight:700}
    .pos-other{color:var(--other)}
    .list{background:#fff;border-radius:6px;padding:6px;margin-top:8px;max-height:260px;overflow:auto;border:1px solid #e6eef0}
    .list .item{padding:8px;border-bottom:1px dashed #eef6f8;cursor:pointer}
    .list .item:last-child{border-bottom:none}
    .danger{color:#b00020;font-weight:700}
    code{background:#f3f7f8;padding:2px 4px;border-radius:4px}
  </style>
</head>
<body>
  <div class="terminal-wrap">
    <div class="terminal-header">
      <h1>∞ Octave Terminal — Speak • Encrypt • Store (single-file)</h1>
    </div>

    <div class="card">
      <div class="controls" aria-hidden="false">
        <button id="btnConversation" class="mode-btn active" title="Conversation mode — store conversation">Conversation</button>
        <button id="btnSecret" class="mode-btn" title="Secret mode — encrypt message and store">Secret message</button>
        <div style="flex:1"></div>
        <div class="small">Wallet:</div>
        <div id="walletBadge" class="wallet-badge">(none)</div>
      </div>

      <div class="panel" id="terminal" role="log" aria-live="polite"></div>

      <div class="input-row">
        <input id="inputLine" class="input-line" placeholder="Type message or command (try /help) — Enter to send" />
        <button id="sendBtn" class="mode-btn">Send</button>
      </div>

      <div class="small" style="margin-top:8px">Everything you type that is stored is appended into this file's embedded store. To persist to GitHub, generate the updated HTML snapshot (command: /export html) and paste it into the repo's index.html.</div>

      <div style="margin-top:10px">
        <div class="small">Entries in this file (click to open):</div>
        <div id="entryList" class="list"></div>
      </div>
    </div>
  </div>

  <!-- Canonical in-file store: wallets and entries.
       THIS BLOCK IS the canonical store that will be updated by the page when you run commands.
       It contains ONLY encrypted blobs (cipher texts) for secrets — passphrases are NOT stored here.
  -->
  <script id="repo_data" type="application/json">
{
  "meta": {
    "created_by": "embed-store",
    "created_at": "2025-11-17T06:47:23Z",
    "current_user": ""
  },
  "wallets": {
  },
  "entries": []
}
  </script>

  <script>
  // Terminal-first, single-file embedded store implementation
  //  - No external server required
  //  - Canonical store is the repo_data script block above
  //  - Commands are entered at the input line. Minimal UI; everything outputs into the terminal.
  //
  // Commands (type in inputLine):
  // /help                        — show short help
  // /login username              — set current wallet id (saved in repo_data)
  // /whoami                      — show current user
  // /open ENTRY_ID               — show entry details (decrypt if encoded; will prompt for passphrase)
  // /spend TOKEN_CODE [ENTRY_ID] — spend a token (marks token.spent=true and links to ENTRY_ID)
  // /list                        — list entries
  // /export html                 — generate full updated HTML and copy to clipboard (manual paste into repo)
  // /export b64                  — generate single-line base64 of HTML (paste into workflow)
  // /help                        — show this help
  //
  // Modes: Conversation (Conversation button active) or Secret message (Secret button active).
  // Conversation stores non-sensitive digest entry (ai summary) and awards token if cooldown elapsed.
  // Secret mode encrypts full message with passphrase you enter and stores only the cipher; passphrase is NOT stored.
  // Each awarded token is unique and stored in wallets[token list] as {code, issued_at, entry_id, spent:false}
  //
  // IMPORTANT: To persist permanently into the repo, use /export html (copy result and paste into repo index.html)
  // or /export b64 to paste into your existing workflow input (archive_b64) — both are one-click copy actions.
  // The page will not transmit passphrases or PATs anywhere.

  // ---------- helpers ----------
  function getRepoData(){
    try{ return JSON.parse(document.getElementById('repo_data').textContent); }
    catch(e){ return {meta:{created_by:'embed-store',created_at:new Date().toISOString(), current_user:''}, wallets:{}, entries:[]}; }
  }
  function saveRepoData(obj){
    document.getElementById('repo_data').textContent = JSON.stringify(obj, null, 2);
    renderAll();
  }
  function nowIso(){ return new Date().toISOString(); }
  function uid(){ return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,8); }

  // ---------- crypto (PBKDF2 -> AES-GCM) ----------
  async function deriveKey(pass, salt, iterations=200000){
    const enc = new TextEncoder();
    const base = await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']);
    return crypto.subtle.deriveKey({name:'PBKDF2', salt, iterations, hash:'SHA-256'}, base, {name:'AES-GCM', length:256}, true, ['encrypt','decrypt']);
  }
  async function encryptText(plain, pass, iterations=200000){
    const enc = new TextEncoder();
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await deriveKey(pass, salt, iterations);
    const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, enc.encode(plain));
    const ctArr = new Uint8Array(ct);
    const combined = new Uint8Array(salt.length + iv.length + ctArr.length);
    combined.set(salt,0); combined.set(iv, salt.length); combined.set(ctArr, salt.length + iv.length);
    let s=''; for(let i=0;i<combined.length;i++) s+=String.fromCharCode(combined[i]);
    return btoa(s);
  }
  async function decryptText(b64, pass, iterations=200000){
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i);
    if(arr.length < 16+12+16) throw new Error('Encoded data too short');
    const salt = arr.slice(0,16), iv = arr.slice(16,28), ct = arr.slice(28);
    const key = await deriveKey(pass, salt, iterations);
    const buf = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct);
    return new TextDecoder().decode(buf);
  }

  // ---------- POS colorizer (light) ----------
  function escapeHtml(s){ return (s||'').replace(/[&<>"']/g,ch=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch])); }
  function posColor(text){
    const words = text.split(/(\s+|[^\s]+)/g).filter(Boolean);
    return words.map(w=>{
      const t = w.trim();
      if(!t) return w;
      const lower = t.toLowerCase();
      if(/^\d+$/.test(lower)) return `<span class="pos-num">${escapeHtml(w)}</span>`;
      if(['is','are','was','were','do','did','have','has','get','make','go','see','say','think','know','write','encrypt','decrypt'].includes(lower)) return `<span class="pos-verb">${escapeHtml(w)}</span>`;
      if(['time','message','conversation','token','wallet','ai','octave','secret','passphrase'].includes(lower)) return `<span class="pos-noun">${escapeHtml(w)}</span>`;
      if(lower.endsWith('ly') || lower.endsWith('ing')) return `<span class="pos-adv">${escapeHtml(w)}</span>`;
      return escapeHtml(w);
    }).join('');
  }

  // ---------- token utilities ----------
  function genTokenCode(){
    // time-based numeric-looking code, unique
    const t = Date.now().toString(36).toUpperCase();
    const r = Math.floor(Math.random()*900000 + 100000).toString(36).toUpperCase();
    return `${t}-${r}`;
  }

  // ---------- repo-data operations ----------
  function ensureWallet(username){
    const d = getRepoData(); d.wallets = d.wallets || {};
    if(!d.wallets[username]) d.wallets[username] = { id: username, balance: 0, last_awarded: 0, tokens: [] };
    saveRepoData(d);
    return getWallet(username);
  }
  function getWallet(username){ const d = getRepoData(); return (d.wallets && d.wallets[username]) || null; }

  function awardTokenToUser(username, entryId){
    const d = getRepoData(); d.wallets = d.wallets || {};
    if(!d.wallets[username]) d.wallets[username] = { id:username, balance:0, last_awarded:0, tokens:[] };
    const w = d.wallets[username];
    const now = Date.now();
    const elapsed = now - (w.last_awarded || 0);
    const COOLDOWN = 30*60*1000;
    if(elapsed >= COOLDOWN){
      const code = genTokenCode();
      const token = { code: code, issued_at: new Date(now).toISOString(), entry_id: entryId, spent: false };
      w.tokens.push(token);
      w.balance = (w.balance || 0) + 1;
      w.last_awarded = now;
      saveRepoData(d);
      return { awarded:true, code, balance:w.balance };
    } else {
      return { awarded:false, cooldown_remaining: Math.ceil((COOLDOWN - elapsed)/1000), balance: w.balance||0 };
    }
  }

  function spendToken(username, code, linkEntryId){
    const d = getRepoData(); const w = (d.wallets && d.wallets[username]) || null;
    if(!w) return { ok:false, error:'no wallet' };
    const tok = (w.tokens||[]).find(t=>t.code === code);
    if(!tok) return { ok:false, error:'token not found' };
    if(tok.spent) return { ok:false, error:'already spent' };
    tok.spent = true; tok.spent_at = new Date().toISOString(); tok.spent_for = linkEntryId || null;
    w.balance = Math.max(0, (w.balance||0) - 1);
    saveRepoData(d);
    return { ok:true, balance:w.balance };
  }

  // ---------- entry operations ----------
  function appendEntryObj(obj){
    const d = getRepoData(); d.entries = d.entries || []; d.entries.push(obj); saveRepoData(d);
  }

  // ---------- UI rendering ----------
  function renderAll(){
    renderList(); renderTerminal(); renderEncoded(); renderWalletBadge();
  }
  function renderList(){
    const list = document.getElementById('entryList');
    list.innerHTML = '';
    const arr = (getRepoData().entries || []).slice().reverse();
    if(arr.length===0){ list.innerHTML = '<div class="small">No entries yet.</div>'; return; }
    arr.forEach(e=>{
      const div = document.createElement('div'); div.className='item';
      div.innerHTML = `<div style="font-weight:700">${escapeHtml(e.id)} &middot; ${escapeHtml(e.type)}</div><div class="small">${escapeHtml(e.timestamp)}</div>`;
      div.addEventListener('click', ()=>openEntry(e.id));
      list.appendChild(div);
    });
  }
  function renderTerminal(){
    const term = document.getElementById('terminal');
    term.innerHTML = '';
    const arr = getRepoData().entries || [];
    arr.forEach(e=>{
      let line = `[${e.timestamp}] (${e.type}) `;
      if(e.type === 'encoded') line += `(encoded) ${e.id}`;
      else line += e.summary || e.text || e.id;
      const div = document.createElement('div');
      if(document.getElementById('pos-toggle') && document.getElementById('pos-toggle').checked) div.innerHTML = posColor(line); else div.textContent = line;
      term.appendChild(div);
    });
    term.scrollTop = term.scrollHeight;
  }
  function renderEncoded(){
    const enc = document.getElementById('encoded');
    const arr = (getRepoData().entries || []).filter(x=>x.type==='encoded');
    enc.innerText = arr.map(e=>`[${e.timestamp}] ${e.id}\n${e.cipher}`).join('\n\n');
  }
  function renderWalletBadge(){
    const badge = document.getElementById('walletBadge');
    const current = (getRepoData().meta && getRepoData().meta.current_user) || '';
    badge.textContent = current ? current : '(none)';
  }

  // ---------- opening entries ----------
  async function openEntry(id){
    const entry = (getRepoData().entries || []).find(x=>x.id === id);
    if(!entry){ alert('entry not found'); return; }
    if(entry.type === 'encoded'){
      const pass = prompt('Enter passphrase to decrypt (never store passphrases in public chat)');
      if(!pass) return;
      try{
        const plain = await PEWPI_CRYPTO.decryptText(entry.cipher, pass);
        appendEntryObjToTerminalDisplay(`DECRYPTED ${id}: ${plain}`);
        // optionally show token info attached
        alert('Decrypted:\n\n' + plain);
      } catch(err){
        alert('Decrypt failed: ' + (err.message || err));
      }
    } else {
      alert(`${entry.type.toUpperCase()} entry:\n\n${entry.summary || entry.text || ''}`);
    }
  }

  function appendEntryObjToTerminalDisplay(s){
    const term = document.getElementById('terminal');
    const d = document.createElement('div'); d.textContent = s;
    term.appendChild(d); term.scrollTop = term.scrollHeight;
  }

  // ---------- input processing (terminal commands) ----------
  async function processInputLine(raw){
    const line = (raw||'').trim();
    if(!line) return;
    // commands start with '/'
    if(line.startsWith('/')){
      const parts = line.split(/\s+/);
      const cmd = parts[0].toLowerCase();
      if(cmd === '/help'){
        appendEntryObjToTerminalDisplay('Commands: /help /login <id> /whoami /list /open <id> /spend <tokencode> [entryId] /export html /export b64');
        return;
      }
      if(cmd === '/login'){
        const id = parts[1];
        if(!id){ appendEntryObjToTerminalDisplay('Usage: /login <username>'); return; }
        const d = getRepoData(); d.meta = d.meta || {}; d.meta.current_user = id; saveRepoData(d);
        ensureWallet(id);
        appendEntryObjToTerminalDisplay('Logged in as ' + id + '. This is now saved into the script store.');
        return;
      }
      if(cmd === '/whoami'){
        const cur = (getRepoData().meta && getRepoData().meta.current_user) || '';
        appendEntryObjToTerminalDisplay('Current user: ' + (cur || '(none)'));
        return;
      }
      if(cmd === '/list'){
        const arr = (getRepoData().entries || []).map(e=>`${e.id} ${e.type} ${e.timestamp}`);
        appendEntryObjToTerminalDisplay('Entries:\\n' + arr.join('\\n'));
        return;
      }
      if(cmd === '/open'){
        const id = parts[1];
        if(!id){ appendEntryObjToTerminalDisplay('Usage: /open <entryId>'); return; }
        openEntry(id);
        return;
      }
      if(cmd === '/spend'){
        const code = parts[1]; const entryId = parts[2] || null;
        if(!code){ appendEntryObjToTerminalDisplay('Usage: /spend <tokenCode> [entryId]'); return; }
        const cur = (getRepoData().meta && getRepoData().meta.current_user);
        if(!cur){ appendEntryObjToTerminalDisplay('Login first with /login <id>'); return; }
        const res = spendToken(cur, code, entryId);
        if(res.ok) appendEntryObjToTerminalDisplay('Token spent. New balance: ' + res.balance);
        else appendEntryObjToTerminalDisplay('Spend failed: ' + res.error);
        return;
      }
      if(cmd === '/export' && parts[1] === 'html'){
        // generate full HTML snapshot with updated repo_data and copy to clipboard and download
        const snapshot = buildFullHtmlSnapshot();
        // copy
        navigator.clipboard.writeText(snapshot).then(()=> appendEntryObjToTerminalDisplay('Full HTML copied to clipboard. Paste into repo index.html to persist.')).catch(()=> appendEntryObjToTerminalDisplay('Copy failed — you can download file instead.'));
        // download
        const blob = new Blob([snapshot], {type:'text/html'}); const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download='index_snapshot.html'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
        return;
      }
      if(cmd === '/export' && parts[1] === 'b64'){
        const snapshot = buildFullHtmlSnapshot();
        const b64 = b64EncodeUnicode(snapshot).replace(/\\n/g,'');
        navigator.clipboard.writeText(b64).then(()=> appendEntryObjToTerminalDisplay('Single-line base64 copied to clipboard (paste into workflow input).')).catch(()=>{ appendEntryObjToTerminalDisplay('Copy failed; generating download.'); const blob=new Blob([b64]); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='snapshot.b64'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });
        return;
      }
      appendEntryObjToTerminalDisplay('Unknown command: ' + cmd + ' — try /help');
      return;
    }

    // otherwise treat as data according to active mode
    const inSecretMode = document.getElementById('btnSecret').classList.contains('active');
    if(inSecretMode){
      // require passphrase prompt
      const pass = prompt('Enter passphrase to encrypt this secret (will NOT be stored):');
      if(!pass){ appendEntryObjToTerminalDisplay('Encrypt aborted — no passphrase entered'); return; }
      try{
        const cipher = await PEWPI_CRYPTO.encryptText(line, pass);
        const entry = { id: uid(), type:'encoded', cipher: cipher, timestamp: nowIso() };
        appendEntryObj(entry);
        // also store a short summary log entry
        appendEntryObj({ id: uid(), type:'log', text: '(stored secret ' + entry.id + ')', timestamp: nowIso() });
        // award token to current user if eligible
        const cur = (getRepoData().meta && getRepoData().meta.current_user);
        if(cur){ const aw = awardTokenToUser(cur, entry.id); if(aw.awarded) appendEntryObjToTerminalDisplay('Secret stored. Awarded token: ' + aw.code + ' balance:' + aw.balance); else appendEntryObjToTerminalDisplay('Secret stored. not awarded (cooldown) balance:' + aw.balance); }
        else appendEntryObjToTerminalDisplay('Secret stored. No wallet logged in — use /login to receive tokens.');
      } catch(err){
        appendEntryObjToTerminalDisplay('Encryption failed: ' + (err.message||err));
      }
    } else {
      // Conversation: store user and AI-digest entry
      appendEntryObj({ id: uid(), type:'user', text: line, timestamp: nowIso() });
      // produce 'ai' digest locally
      const digest = (line.split(/\s+/).slice(0,40).join(' '));
      appendEntryObj({ id: uid(), type:'ai', summary: 'Octave distilled: ' + digest, timestamp: nowIso() });
      const cur = (getRepoData().meta && getRepoData().meta.current_user);
      if(cur){
        const aw = awardTokenToUser(cur, null);
        if(aw.awarded) appendEntryObjToTerminalDisplay('Conversation stored. Token awarded: ' + aw.code + ' balance:' + aw.balance);
        else appendEntryObjToTerminalDisplay('Conversation stored. Not awarded (cooldown). Balance:' + aw.balance);
      } else appendEntryObjToTerminalDisplay('Conversation stored. /login to link tokens to your wallet.');
    }
    renderAll();
  }

  // build full HTML snapshot replacing the repo_data block with current JSON
  function buildFullHtmlSnapshot(){
    const clone = document.documentElement.cloneNode(true);
    // find repo_data in clone and replace text
    const repoEl = clone.querySelector('#repo_data');
    if(repoEl) repoEl.textContent = JSON.stringify(getRepoData(), null, 2);
    else {
      const s = clone.ownerDocument.createElement('script');
      s.id = 'repo_data'; s.type = 'application/json'; s.textContent = JSON.stringify(getRepoData(), null, 2);
      clone.querySelector('body').appendChild(s);
    }
    return '<!doctype html>\\n' + clone.outerHTML;
  }

  // spend token wrapper used by /spend command
  function spendToken(username, code, entryId){
    const d = getRepoData();
    const w = (d.wallets && d.wallets[username]) || null;
    if(!w) return { ok:false, error:'no wallet' };
    const tok = (w.tokens || []).find(t=>t.code === code);
    if(!tok) return { ok:false, error:'token not found' };
    if(tok.spent) return { ok:false, error:'already spent' };
    tok.spent = true; tok.spent_at = new Date().toISOString(); tok.spent_for = entryId || null;
    w.balance = Math.max(0, (w.balance||0) - 1);
    saveRepoData(d);
    return { ok:true, balance:w.balance };
  }

  // init: wire controls
  document.getElementById('btnConversation').addEventListener('click', ()=>{ document.getElementById('btnConversation').classList.add('active'); document.getElementById('btnSecret').classList.remove('active'); appendEntryObjToTerminalDisplay('Mode: Conversation'); });
  document.getElementById('btnSecret').addEventListener('click', ()=>{ document.getElementById('btnSecret').classList.add('active'); document.getElementById('btnConversation').classList.remove('active'); appendEntryObjToTerminalDisplay('Mode: Secret message'); });
  document.getElementById('sendBtn').addEventListener('click', ()=>processAndClear());
  document.getElementById('inputLine').addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); processAndClear(); }});
  document.getElementById('btn-login').addEventListener('click', ()=>{ const id = prompt('Set wallet id (unique):'); if(!id) return; const d = getRepoData(); d.meta = d.meta || {}; d.meta.current_user = id; saveRepoData(d); ensureWallet(id); appendEntryObjToTerminalDisplay('Wallet set: ' + id); });
  document.getElementById('btn-gen').addEventListener('click', ()=>{ const arr=crypto.getRandomValues(new Uint8Array(16)); let s=btoa(String.fromCharCode.apply(null,Array.from(arr))).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'').slice(0,24); passEl.value = s; appendEntryObjToTerminalDisplay('Passphrase generated (local)'); });
  document.getElementById('btn-conv').classList.add('active');

  function processAndClear(){ const v = document.getElementById('inputLine').value; if(!v.trim()) return; processInputLine(v); document.getElementById('inputLine').value=''; }

  // expose a small API for console usage if needed
  window.PEWPI = { getRepoData, saveRepoData, appendEntryObj, awardTokenToUser, spendToken, buildFullHtmlSnapshot };

  // render initially
  renderAll();
  appendEntryObjToTerminalDisplay('Terminal ready — type /help for commands. All stored data is inside the embedded script block in this file.');
  </script>
</body>
</html>