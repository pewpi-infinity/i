<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Octave OS — Octave Logger & Pewpi Secret Encoder</title>
  <style>
    /* preserved look & feel; restored the original cool blue text color for the terminal */
    :root{
      --page-bg: #e9f1f5;
      --terminal-bg: #0b3b4a; /* dark teal terminal background */
      --terminal-text-blue: #7be6ff; /* the "cool" blue cyan used for terminal text */
      --card-bg: #ffffff;
      --muted: #667a80;
      --accent-dark: #08303b;
      --panel-bg: #f8fbfc;
      --panel-border: #e6eef0;
    }

    body { font-family: system-ui, -apple-system, Roboto, "Helvetica Neue", Arial; background:var(--page-bg); color:var(--accent-dark); padding:20px; }
    .terminal { background:var(--terminal-bg); color:var(--terminal-text-blue); padding:18px; border-radius:10px; max-width:920px; margin: 0 auto 18px; font-family: monospace; }
    .card { background:var(--card-bg); max-width:920px; margin: 0 auto; padding:18px; border-radius:10px; box-shadow: 0 6px 18px rgba(8,48,59,0.06); }
    h1 { margin:0 0 8px 0; font-size:20px; color:var(--accent-dark); }
    label { color:var(--accent-dark); font-weight:600; display:block; margin-bottom:6px; }
    textarea, input[type="text"] { width:100%; font-size:14px; padding:10px; box-sizing:border-box; border:1px solid #d6e2e6; border-radius:6px; }
    textarea { min-height:120px; resize:vertical; }
    .controls { margin-top:12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { padding:8px 12px; border-radius:6px; border:1px solid #bfcfd3; background:#f6f8f9; cursor:pointer; }
    .row { display:flex; gap:8px; align-items:center; }
    .col { flex:1; }
    .boxed { border:1px dashed #d6e2e6; padding:12px; border-radius:6px; background:#fbfdfe; margin-top:12px; }
    .label-small { font-size:13px; color:var(--muted); margin-top:10px; }
    #status { display:block; margin-top:12px; min-height:20px; color:#b00020; font-weight:600; }
    .outputs { display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:14px; }
    @media (max-width:760px){ .outputs { grid-template-columns:1fr } }
    .panel { background:var(--panel-bg); border-radius:6px; padding:10px; min-height:140px; border:1px solid var(--panel-border); white-space:pre-wrap; overflow:auto; }
    .muted { color:var(--muted); font-size:13px; }
    .toggle { display:inline-flex; gap:6px; align-items:center; padding:6px; background:#eef6f8; border-radius:6px; border:1px solid #d6e2e6; }
  </style>
</head>
<body>
  <div class="terminal">
    Octave OS — Octave Logger & Pewpi Secret Encoder
    <div style="margin-top:8px; color:var(--terminal-text-blue);">Type a message, toggle mode, and press Submit. The page runs fully in your browser; no secrets are sent unless you choose to.</div>
  </div>

  <div class="card">
    <h1>Input</h1>
    <label for="input-box">Type message / conversation</label>
    <textarea id="input-box" placeholder="Write a message, a prompt for the AI, or a secret message to encode..."></textarea>

    <div class="controls" style="margin-top:10px;">
      <div class="toggle">
        <input id="mode-toggle" type="checkbox" />
        <label for="mode-toggle" style="margin:0">Conversation mode</label>
      </div>
      <button id="submit-btn">Submit</button>
      <button id="auto-encode" title="When checked, AI conversation outputs will be auto-encoded into the encoded panel">Auto-encode AI output</button>
      <button id="clear-input">Clear</button>
      <span id="status" aria-live="polite"></span>
    </div>

    <div class="label-small">Notes:
      - Conversation mode: sends the input to a local /ai endpoint (if available) to retrieve AI responses. If no server is available a local demo AI will respond.
      - Encode mode: encrypts the input into a single encoded blob. The passphrase is required to decode.
    </div>

    <div class="outputs">
      <div>
        <h2 style="margin:8px 0 6px 0">AI Conversation Output</h2>
        <div id="ai-output" class="panel" aria-live="polite"></div>
      </div>

      <div>
        <h2 style="margin:8px 0 6px 0">Encoded / Decoded Output</h2>
        <div id="encoded-output" class="panel" readonly></div>
      </div>
    </div>

    <div class="boxed" style="margin-top:14px;">
      <h2 style="margin:4px 0">Terminal — passphrase & retrieve</h2>
      <div class="row" style="margin-bottom:8px;">
        <div class="col">
          <label for="passphrase">Passphrase (enter or generate)</label>
          <input id="passphrase" type="text" placeholder="Enter or generate passphrase here (keep it private)">
        </div>
        <div style="width:140px;">
          <label>&nbsp;</label>
          <button id="gen-pass">Generate</button>
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div class="col">
          <button id="decrypt-btn">Retrieve (decrypt encoded string)</button>
        </div>
        <div style="width:180px;">
          <button id="copy-encoded">Copy encoded</button>
        </div>
      </div>

      <div class="label-small" style="margin-top:8px;">
        To share a secret: give recipient the encoded blob (from Encoded Output) + the passphrase. They can paste both into this page to retrieve the decoded message.
      </div>
    </div>

  </div>

  <script>
    // --- Crypto helpers (PBKDF2 -> AES-GCM) ---
    function toBase64(bytes) {
      let s = '';
      for (let i = 0; i < bytes.length; i++) s += String.fromCharCode(bytes[i]);
      return btoa(s);
    }
    function fromBase64(b64) {
      const bin = atob(b64);
      const len = bin.length;
      const arr = new Uint8Array(len);
      for (let i = 0; i < len; i++) arr[i] = bin.charCodeAt(i);
      return arr;
    }

    async function deriveKey(passphrase, salt, iterations) {
      const enc = new TextEncoder();
      const baseKey = await crypto.subtle.importKey('raw', enc.encode(passphrase), { name: 'PBKDF2' }, false, ['deriveKey']);
      const key = await crypto.subtle.deriveKey(
        { name: 'PBKDF2', salt: salt, iterations: iterations, hash: 'SHA-256' },
        baseKey,
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
      );
      return key;
    }

    async function encryptMessage(plaintext, passphrase, iterations = 200000) {
      const enc = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(passphrase, salt, iterations);
      const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, enc.encode(plaintext));
      const ctArr = new Uint8Array(ciphertext);
      const combined = new Uint8Array(salt.length + iv.length + ctArr.length);
      combined.set(salt, 0);
      combined.set(iv, salt.length);
      combined.set(ctArr, salt.length + iv.length);
      return toBase64(combined);
    }

    async function decryptMessage(b64, passphrase, iterations = 200000) {
      const combined = fromBase64(b64);
      if (combined.length < 16 + 12 + 16) throw new Error('Encoded data too short or invalid');
      const salt = combined.slice(0, 16);
      const iv = combined.slice(16, 28);
      const ct = combined.slice(28);
      const key = await deriveKey(passphrase, salt, iterations);
      const plainBuffer = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
      return new TextDecoder().decode(plainBuffer);
    }

    // --- UI wiring & behavior ---
    document.addEventListener('DOMContentLoaded', () => {
      const inputBox = document.getElementById('input-box');
      const modeToggle = document.getElementById('mode-toggle');
      const submitBtn = document.getElementById('submit-btn');
      const aiOutput = document.getElementById('ai-output');
      const encodedOutput = document.getElementById('encoded-output');
      const status = document.getElementById('status');
      const passphraseEl = document.getElementById('passphrase');
      const genPassBtn = document.getElementById('gen-pass');
      const decryptBtn = document.getElementById('decrypt-btn');
      const copyEncodedBtn = document.getElementById('copy-encoded');
      const autoEncodeBtn = document.getElementById('auto-encode');
      const clearInputBtn = document.getElementById('clear-input');

      let autoEncode = false;
      autoEncodeBtn.addEventListener('click', () => {
        autoEncode = !autoEncode;
        autoEncodeBtn.style.background = autoEncode ? '#dff7e7' : '#f6f8f9';
        autoEncodeBtn.textContent = autoEncode ? 'Auto-encode: ON' : 'Auto-encode AI output';
      });

      function setStatus(msg, isError=false) {
        status.textContent = msg;
        status.style.color = isError ? '#b00020' : '#0a6f2b';
      }

      // small passphrase generator (base64url-like)
      function genPassphrase(lenBytes = 16) {
        const arr = crypto.getRandomValues(new Uint8Array(lenBytes));
        return toBase64(arr).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
      }
      genPassBtn.addEventListener('click', () => {
        passphraseEl.value = genPassphrase(16);
        setStatus('Passphrase generated. Keep it private.');
      });

      // simulate local AI response if no server exists
      async function simulateAiResponse(prompt) {
        await new Promise(r => setTimeout(r, 300));
        const lines = [
          "Octave OS analysis:",
          `"${prompt.slice(0,200)}"`,
          "— distilled context for Octave: " + prompt.split(/\s+/).slice(0,20).join(' ')
        ];
        return lines.join("\n");
      }

      async function fetchAiResponse(prompt) {
        try {
          const resp = await fetch('/ai', { method: 'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ prompt }) });
          if (!resp.ok) throw new Error('no ai');
          const j = await resp.json();
          return j.text || JSON.stringify(j);
        } catch (e) {
          return await simulateAiResponse(prompt);
        }
      }

      submitBtn.addEventListener('click', async () => {
        setStatus('', false);
        const text = inputBox.value || '';
        if (!text.trim()) { setStatus('Type something to submit', true); return; }

        if (modeToggle.checked) {
          setStatus('Getting AI response...', false);
          const aiText = await fetchAiResponse(text);
          aiOutput.textContent = (aiOutput.textContent ? aiOutput.textContent + "\n\n" : "") + "USER: " + text + "\n\nAI: " + aiText;
          setStatus('AI response appended.');
          if (autoEncode) {
            let pass = passphraseEl.value;
            if (!pass) {
              pass = genPassphrase(16);
              passphraseEl.value = pass;
              setStatus('Passphrase auto-generated for encoding. Keep it safe.');
            }
            try {
              const encoded = await encryptMessage(aiText, pass, 200000);
              encodedOutput.textContent = encodedOutput.textContent ? encodedOutput.textContent + "\n\n" + encoded : encoded;
              setStatus('AI response encrypted and appended to Encoded Output.');
            } catch (e) {
              setStatus('Encoding failed: ' + e.message, true);
            }
          }
        } else {
          let pass = passphraseEl.value;
          if (!pass) {
            pass = genPassphrase(16);
            passphraseEl.value = pass;
            setStatus('No passphrase provided — one was generated. Keep it private.');
          } else {
            setStatus('Encrypting...', false);
          }
          try {
            const encoded = await encryptMessage(text, pass, 200000);
            encodedOutput.textContent = encodedOutput.textContent ? encodedOutput.textContent + "\n\n" + encoded : encoded;
            setStatus('Message encrypted. Share encoded blob + passphrase to recipient.');
            aiOutput.textContent = (aiOutput.textContent ? aiOutput.textContent + "\n\n" : "") + "ENCODED_MESSAGE_CREATED_AT: " + new Date().toISOString();
          } catch (e) {
            setStatus('Encryption failed: ' + e.message, true);
          }
        }
        inputBox.value = '';
      });

      decryptBtn.addEventListener('click', async () => {
        setStatus('', false);
        const pass = passphraseEl.value || '';
        if (!pass.trim()) { setStatus('Enter passphrase to retrieve', true); return; }
        const enc = encodedOutput.textContent || '';
        if (!enc.trim()) { setStatus('No encoded text available in Encoded Output', true); return; }
        const parts = enc.trim().split(/\n\s*\n/);
        const last = parts[parts.length - 1].trim();
        try {
          setStatus('Decrypting...', false);
          const decoded = await decryptMessage(last, pass, 200000);
          aiOutput.textContent = (aiOutput.textContent ? aiOutput.textContent + "\n\n" : "") + "RETRIEVED: " + decoded;
          setStatus('Retrieved and appended to AI Conversation Output.');
        } catch (e) {
          setStatus('Decryption failed: ' + (e.message || e), true);
        }
      });

      copyEncodedBtn.addEventListener('click', async () => {
        const enc = encodedOutput.textContent || '';
        if (!enc.trim()) { setStatus('No encoded text to copy', true); return; }
        try {
          await navigator.clipboard.writeText(enc);
          setStatus('Encoded text copied to clipboard.');
        } catch (e) {
          setStatus('Copy failed: ' + e.message, true);
        }
      });

      clearInputBtn.addEventListener('click', () => { inputBox.value=''; setStatus(''); });
    });
  </script>
</body>
</html>