<!doctype html>
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = https://github.com/pewpi-infinity/infinity-brain-111.git
	fetch = +refs/heads/main:refs/remotes/origin/main
[branch "main"]
	remote = origin
	merge = refs/heads/main
<!-- üê∂ PEWPI SIGN-IN (GLOBAL) -->
<div id="pewpi-gate">
  <h1>üê∂ pewpi</h1>
  <input id="pewpi_user" placeholder="Handle">
  <button onclick="pewpiUnlock()">Enter</button>
</div>
<script>
function pewpiUnlock(){
  localStorage.setItem("pewpi_user", document.getElementById("pewpi_user").value);
  document.getElementById("pewpi-gate").style.display="none";
  document.body.classList.add("pewpi-live");
}
if(localStorage.getItem("pewpi_user")){
  document.addEventListener("DOMContentLoaded",()=>{
    const g=document.getElementById("pewpi-gate");
    if(g) g.style.display="none";
    document.body.classList.add("pewpi-live");
  });
}
</script>
<style>
#pewpi-gate{position:fixed;inset:0;background:#0e0e0e;color:#fff;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:9999}
#pewpi-gate button{background:#ff69b4;border:0;padding:10px 18px}
body:not(.pewpi-live)>*:not(#pewpi-gate){filter:blur(6px);pointer-events:none}
</style>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>‚àû i</title>
  <style>
    :root{
      --page-bg: #e9f1f5;
      --terminal-bg: #0b3b4a;
      --terminal-text-blue: #7be6ff; /* original cool cyan used in terminal help */
      --card-bg: #ffffff;
      --panel-bg: #f8fbfc;
      --panel-border: #e6eef0;
      --accent-dark: #08303b;
      --muted: #667a80;

      /* POS color mapping (you asked for blue/green/yellow/orange/red primarily) */
      --color-noun: #f2d024;    /* yellow for nouns */
      --color-verb: #2fb86a;    /* green for verbs */
      --color-adj:  #4fb8e0;    /* blue for adjectives */
      --color-adv:  #ff9a3c;    /* orange for adverbs */
      --color-other:#e14b4b;    /* red for other / punctuation / fallback */
      --color-num:  #c66eff;    /* purple-ish for numbers/proper nouns */
    }

    body{font-family: system-ui, -apple-system, Roboto, "Helvetica Neue", Arial; background:var(--page-bg); color:var(--accent-dark); padding:18px;}
    .terminal{background:var(--terminal-bg); color:var(--terminal-text-blue); padding:16px; border-radius:10px; max-width:920px; margin:0 auto 16px; font-family: monospace;}
    .card{background:var(--card-bg); max-width:920px; margin:0 auto; padding:16px; border-radius:10px; box-shadow:0 6px 18px rgba(8,48,59,0.06);}
    h1{margin:0 0 8px 0; font-size:20px; color:var(--accent-dark)}
    label{color:var(--accent-dark); font-weight:600; display:block; margin-bottom:6px;}
    textarea,input[type="text"]{width:100%; font-size:14px; padding:10px; box-sizing:border-box; border:1px solid #d6e2e6; border-radius:6px;}
    textarea{min-height:120px; resize:vertical;}
    .controls{margin-top:12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    button{padding:8px 12px; border-radius:6px; border:1px solid #bfcfd3; background:#f6f8f9; cursor:pointer;}
    .row{display:flex; gap:8px; align-items:center;}
    .col{flex:1;}
    .boxed{border:1px dashed #d6e2e6; padding:12px; border-radius:6px; background:#fbfdfe; margin-top:12px;}
    .label-small{font-size:13px; color:var(--muted); margin-top:10px;}
    #status{display:block; margin-top:12px; min-height:20px; color:#b00020; font-weight:600;}
    .outputs{display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:14px;}
    @media (max-width:760px){.outputs{grid-template-columns:1fr}}
    .panel{background:var(--panel-bg); border-radius:6px; padding:10px; min-height:140px; border:1px solid var(--panel-border); white-space:pre-wrap; overflow:auto; color:var(--accent-dark);}
    .token{padding:0 0.08rem; border-radius:2px;}
    .pos-noun{color:var(--color-noun); font-weight:700;}
    .pos-verb{color:var(--color-verb); font-weight:700;}
    .pos-adj{color:var(--color-adj);}
    .pos-adv{color:var(--color-adv);}
    .pos-num{color:var(--color-num); font-weight:700;}
    .pos-other{color:var(--color-other);}
  </style>
</head>
<body>
  <div class="terminal">
    Octave OS ‚Äî Octave Logger & Pewpi Secret Encoder
    <div style="margin-top:8px; color:var(--terminal-text-blue);">
      Type a message, toggle mode, press Enter (or click Submit). All saved logs are encrypted by default; a small digest is kept for AI ingestion.
      <button onclick="location.href='terminal.html'" style="float:right; background:var(--terminal-text-blue); color:var(--terminal-bg); border:0; padding:6px 12px; border-radius:6px; cursor:pointer; font-weight:600;">
        üß± Open Terminal
      </button>
    <div style="margin-top:8px; color:var(--terminal-text-blue);">Type a message, toggle mode, press Enter (or click Submit). All saved logs are encrypted by default; a small digest is kept for AI ingestion.</div>
    <div style="margin-top:12px;">
      <a href="terminal.html" style="color:var(--terminal-text-blue); text-decoration:none; display:inline-flex; align-items:center; gap:6px; padding:6px 12px; border:1px solid var(--terminal-text-blue); border-radius:4px; font-size:13px; transition:all 0.3s ease;" onmouseover="this.style.background='rgba(123,230,255,0.1)'" onmouseout="this.style.background='transparent'">
        <span style="font-size:16px;">‚ö°</span> Open Integration Terminal
      </a>
    </div>
  </div>

  <div class="card">
    <h1>Input</h1>
    <label for="input-box">Type message / conversation</label>
    <textarea id="input-box" placeholder="Write message, AI prompt, or secret..."></textarea>

    <div class="controls">
      <label style="display:flex;align-items:center;gap:8px"><input id="mode-toggle" type="checkbox"> Conversation mode</label>
      <label style="display:flex;align-items:center;gap:8px"><input id="auto-encode" type="checkbox"> Auto-encode AI output</label>
      <button id="submit-btn">Submit</button>
      <button id="clear-input">Clear</button>
      <label style="margin-left:8px;"><input id="pos-toggle" type="checkbox" checked> POS color</label>
      <span class="label-small" style="margin-left:auto">Press Enter (no Shift) to submit, Shift+Enter for newline</span>
    </div>

    <div class="label-small">Notes: logs are encrypted locally with a passphrase you provide when encrypting. A small human-readable context (digest) is stored unencrypted for Octave ingestion only.</div>

    <div class="outputs">
      <div>
        <h2 style="margin:8px 0 6px 0; color:var(--terminal-text-blue)">AI Conversation Output</h2>
        <div id="ai-output" class="panel" aria-live="polite"></div>
      </div>

      <div>
        <h2 style="margin:8px 0 6px 0; color:var(--terminal-text-blue)">Encoded / Stored Log Output</h2>
        <div id="encoded-output" class="panel" readonly></div>
      </div>
    </div>

    <div class="boxed">
      <h2 style="margin:4px 0">Terminal ‚Äî passphrase & retrieve</h2>
      <div class="row" style="margin-bottom:8px;">
        <div class="col">
          <label for="passphrase">Passphrase (enter or generate)</label>
          <input id="passphrase" type="text" placeholder="Enter or generate passphrase here (keep it private)">
        </div>
        <div style="width:140px">
          <label>&nbsp;</label>
          <button id="gen-pass">Generate</button>
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div class="col"><button id="decrypt-btn">Retrieve last encoded (decrypt)</button></div>
        <div style="width:180px"><button id="copy-encoded">Copy encoded panel</button></div>
      </div>

      <div class="label-small" style="margin-top:8px;">Share the encoded blob + passphrase to the recipient. Admin can decrypt using passphrase here.</div>
    </div>
  </div>

  <!-- Embedded in-file canonical store ‚Äî added to integrate with embedded-writer and bridge.
       This keeps a canonical copy of logs/entries inside the HTML itself (so you can export the HTML
       and the full conversation history lives in the file). -->
  <script id="repo_data" type="application/json">
{
  "meta": {
    "created_by": "index_Version9",
    "created_at": "2025-11-17T07:36:58Z",
    "current_user": ""
  },
  "wallets": {},
  "entries": [],
  "log_txt": "",
  "embedded_files": {}
}
  </script>

<script>
/* =============================================================================
   Octave index.html - Improved:
   - POS coloring: nouns=yellow, verbs=green, adj=blue, adv=orange, others=red, nums/pN=purple
   - Enter handling: Enter (no Shift) submits; Shift+Enter inserts newline
   - Local storage: every saved "sensitive" entry is encrypted and stored (encoded),
     while a short distilled digest is kept as 'ai' record (plain text) for ingestion.
   - Reliable logging: append to localStorage, render to panels, queue for server push.
   - Integration: this file now writes into the in-file repo_data (via the bridge) so that
     the embedded-writer and token systems keep a canonical log inside the HTML.
   ============================================================================= */

const STORAGE_KEY = 'octave_logs_v2';

function nowIso(){ return new Date().toISOString(); }
function loadLogs(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'); }catch(e){return [];}}
function saveLogs(logs){ localStorage.setItem(STORAGE_KEY, JSON.stringify(logs)); }

/* --------------------------
   Crypto: PBKDF2 -> AES-GCM
   (browser WebCrypto)
   -------------------------- */
function uint8FromBase64(b64){
  const bin = atob(b64); const arr = new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i);
  return arr;
}
function base64FromUint8(u8){ let s=''; for(let i=0;i<u8.length;i++) s+=String.fromCharCode(u8[i]); return btoa(s); }

async function deriveKey(passphrase, salt, iterations){
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey('raw', enc.encode(passphrase), {name:'PBKDF2'}, false, ['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2', salt, iterations, hash:'SHA-256'}, baseKey, {name:'AES-GCM', length:256}, true, ['encrypt','decrypt']);
}

    <div class="controls">
        <select id="method">
            <option value="secure-commit">Secure Commit (via server - RECOMMENDED)</option>
            <option value="github">GitHub (direct commit from browser - DEPRECATED)</option>
            <option value="server">Local server (POST /log)</option>
            <option value="fs">Local file (File System Access API)</option>
        </select>
        <input id="secret" type="password" placeholder="Commit secret" style="width:220px" />
        <button id="saveSecret">Save Secret</button>
        <input id="token" type="text" placeholder="GitHub token (deprecated)" style="width:220px;display:none;" />
        <button id="saveToken" style="display:none;">Save Token</button>
    </div>

    <input id="cmd" placeholder="Type here‚Ä¶" autocomplete="off" autocorrect="off" autocapitalize="off" />
    <div class="note">Note: "Secure Commit" uses server-side GitHub authentication (no token in browser). Configure secret to match server.</div>
            <option value="github-server">GitHub (secure server commit) - RECOMMENDED</option>
            <option value="github">GitHub (direct commit from browser) - DEPRECATED</option>
            <option value="server">Local server (POST /log)</option>
            <option value="fs">Local file (File System Access API)</option>
        </select>
        <input id="token" type="text" placeholder="Token/Secret for selected method" style="width:360px" />
        <button id="saveToken">Save Token</button>
    </div>

    <input id="cmd" placeholder="Type here‚Ä¶" autocomplete="off" autocorrect="off" autocapitalize="off" />
    <div class="note">Note: GitHub (secure server) method uses a server-side endpoint to safely commit. Direct browser method is deprecated due to security risks.</div>
async function encryptText(plaintext, passphrase, iterations=200000){
  // prefer existing global implementation if bridge provided it
  if(window.PEWPI_BRIDGE && typeof window.PEWPI_BRIDGE.encryptText === 'function'){
    return window.PEWPI_BRIDGE.encryptText(plaintext, passphrase, iterations);
  }
  const enc = new TextEncoder();
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKey(passphrase, salt, iterations);
  const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, enc.encode(plaintext));
  const ctarr = new Uint8Array(ct);
  const combined = new Uint8Array(salt.length + iv.length + ctarr.length);
  combined.set(salt,0); combined.set(iv, salt.length); combined.set(ctarr, salt.length+iv.length);
  return base64FromUint8(combined);
}

async function decryptText(b64, passphrase, iterations=200000){
  // prefer existing global implementation if bridge provided it
  if(window.PEWPI_BRIDGE && typeof window.PEWPI_BRIDGE.decryptText === 'function'){
    return window.PEWPI_BRIDGE.decryptText(b64, passphrase, iterations);
  }
  const combined = uint8FromBase64(b64);
  if (combined.length < 16+12+16) throw new Error('Encoded data too short or invalid');
  const salt = combined.slice(0,16);
  const iv = combined.slice(16,28);
  const ct = combined.slice(28);
  const key = await deriveKey(passphrase, salt, iterations);
  const plain = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct);
  return new TextDecoder().decode(plain);
}

/* --------------------------
   POS tagging & coloring
   - lightweight heuristics + lists
   - groups contiguous nouns into noun-phrases to color as a unit
   -------------------------- */
const VERBS = new Set(['be','is','are','was','were','am','have','has','had','do','does','did','say','says','said','get','got','make','made','go','went','know','knew','take','took','see','saw','come','came','think','thought','look','looked','want','wanted','give','gave','use','used','find','found','tell','told','ask','asked','work','worked','seem','seemed','feel','felt','try','tried','leave','left','call','called','append','append','write','wrote','encrypt','decrypt']);
const NOUNS = new Set(['time','person','year','way','day','thing','man','world','life','hand','part','child','eye','woman','place','work','week','case','point','government','company','number','group','problem','fact','message','context','conversation','ai','octave','log','entry','secret','passphrase']);
const ADJS = new Set(['good','new','first','last','long','great','little','own','other','old','right','big','high','different','small','large','next','early','young','important','few','public','bad','same','able','encrypted','encoded']);
const PRONOUNS = new Set(['i','you','he','she','it','we','they','me','him','her','us','them','this','that','these','those']);
const NUM_RE = /^\d+([.,]\d+)?$/;

function escapeHtml(s){ return s.replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[ch])); }

function tokenizeWithSpaces(text){
  const re = /(\s+|[A-Za-z√Ä-√ñ√ò-√∂√∏-√ø0-9]+|[^\sA-Za-z0-9]+)/g;
  return text.match(re) || [];
}

<script src="static/js/commit-client.js"></script>
<script>
const terminal = document.getElementById("terminal");
const input = document.getElementById("cmd");
const methodSelect = document.getElementById("method");
const tokenInput = document.getElementById("token");
const saveTokenBtn = document.getElementById("saveToken");
const secretInput = document.getElementById("secret");
const saveSecretBtn = document.getElementById("saveSecret");

const OWNER = 'pewpi-infinity';
const REPO = 'i';
const PATH = 'logs/txt.log';

// Load saved token from localStorage (for deprecated method)
tokenInput.value = localStorage.getItem('GH_LOG_TOKEN') || '';
// Load saved token/secret from localStorage based on method
function loadTokenForMethod() {
    const method = methodSelect.value;
    if (method === 'github-server') {
        tokenInput.value = localStorage.getItem('COMMIT_SECRET') || '';
        tokenInput.placeholder = 'Commit secret (from server .env)';
    } else if (method === 'github') {
        tokenInput.value = localStorage.getItem('GH_LOG_TOKEN') || '';
        tokenInput.placeholder = 'GitHub token (deprecated)';
    } else {
        tokenInput.value = '';
        tokenInput.placeholder = 'Token/Secret for selected method';
    }
}

loadTokenForMethod();

// Update token placeholder when method changes
methodSelect.addEventListener('change', loadTokenForMethod);

// Load saved secret from localStorage (for secure commit)
secretInput.value = localStorage.getItem('COMMIT_SECRET') || '';

// Configure CommitClient if secret is available
if (secretInput.value) {
    CommitClient.configure({
        serverUrl: 'http://localhost:3000',
        secret: secretInput.value
    });
}

// Show/hide token input based on method
methodSelect.addEventListener('change', () => {
    const method = methodSelect.value;
    if (method === 'github') {
        tokenInput.style.display = 'inline';
        saveTokenBtn.style.display = 'inline';
        secretInput.style.display = 'none';
        saveSecretBtn.style.display = 'none';
    } else if (method === 'secure-commit') {
        tokenInput.style.display = 'none';
        saveTokenBtn.style.display = 'none';
        secretInput.style.display = 'inline';
        saveSecretBtn.style.display = 'inline';
    } else {
        tokenInput.style.display = 'none';
        saveTokenBtn.style.display = 'none';
        secretInput.style.display = 'none';
        saveSecretBtn.style.display = 'none';
    }
});

saveSecretBtn.addEventListener('click', () => {
    const s = secretInput.value.trim();
    if (s) {
        localStorage.setItem('COMMIT_SECRET', s);
        CommitClient.configure({
            serverUrl: 'http://localhost:3000',
            secret: s
        });
        printToTerminal('‚úî secret saved to localStorage');
    } else {
        localStorage.removeItem('COMMIT_SECRET');
        printToTerminal('‚ö† secret cleared');
    }
});

saveTokenBtn.addEventListener('click', () => {
    const t = tokenInput.value.trim();
    const method = methodSelect.value;
    
    if (t) {
        if (method === 'github-server') {
            localStorage.setItem('COMMIT_SECRET', t);
            if (window.CommitClient) {
                CommitClient.setSecret(t);
            }
            printToTerminal('‚úî commit secret saved to localStorage');
        } else if (method === 'github') {
            localStorage.setItem('GH_LOG_TOKEN', t);
            printToTerminal('‚úî GitHub token saved to localStorage');
        } else {
            printToTerminal('‚ö† No token storage for this method');
        }
    } else {
        if (method === 'github-server') {
            localStorage.removeItem('COMMIT_SECRET');
            if (window.CommitClient) {
                CommitClient.clearSecret();
            }
        } else {
            localStorage.removeItem('GH_LOG_TOKEN');
        }
        printToTerminal('‚ö† token cleared');
function guessPosForToken(tok){
  const t = tok.trim();
  if (!t) return 'space';
  if (NUM_RE.test(t)) return 'num';
  if (/^[^\w]+$/.test(t)) return 'other';
  const lower = t.toLowerCase();
  if (PRONOUNS.has(lower)) return 'noun';
  if (VERBS.has(lower)) return 'verb';
  if (NOUNS.has(lower)) return 'noun';
  if (ADJS.has(lower)) return 'adj';
  if (lower.endsWith('ing')||lower.endsWith('ed')||lower.endsWith('ize')||lower.endsWith('ise')) return 'verb';
  if (lower.endsWith('ly')) return 'adv';
  if (lower.endsWith('ion')||lower.endsWith('ment')||lower.endsWith('ness')||lower.endsWith('ity')) return 'noun';
  if (lower.length<=3) return 'other';
  if (/^[A-Z][a-z]/.test(t)) return 'prop';
  return 'noun';
}

function posColorizeText(text){
  const tokens = tokenizeWithSpaces(text);
  const posArr = tokens.map(tok => ({tok, pos: guessPosForToken(tok)}));
  const parts = [];
  let i=0;
  while(i<posArr.length){
    if (posArr[i].pos==='noun' || posArr[i].pos==='prop' || posArr[i].pos==='num'){
      let j=i;
      let buf = '';
      while(j<posArr.length && (posArr[j].pos==='noun' || posArr[j].pos==='prop' || posArr[j].pos==='num' || /^\s+$/.test(posArr[j].tok) || /^[,.:;]$/.test(posArr[j].tok))){
        buf += posArr[j].tok;
        j++;
      }
      parts.push({text:buf, pos: posArr[i].pos==='prop' ? 'prop' : (posArr[i].pos==='num' ? 'num' : 'noun')});
      i=j;
    } else {
      parts.push({text:posArr[i].tok, pos:posArr[i].pos});
      i++;
    }
  }
  return parts.map(p => {
    if (/^\s+$/.test(p.text)) return escapeHtml(p.text);
    switch(p.pos){
      case 'noun': return `<span class="token pos-noun">${escapeHtml(p.text)}</span>`;
      case 'verb': return `<span class="token pos-verb">${escapeHtml(p.text)}</span>`;
      case 'adj':  return `<span class="token pos-adj">${escapeHtml(p.text)}</span>`;
      case 'adv':  return `<span class="token pos-adv">${escapeHtml(p.text)}</span>`;
      case 'num':  return `<span class="token pos-num">${escapeHtml(p.text)}</span>`;
      case 'prop': return `<span class="token pos-num">${escapeHtml(p.text)}</span>`;
      default:     return `<span class="token pos-other">${escapeHtml(p.text)}</span>`;
    }
  }).join('');
}

/* --------------------------
   Logging: store encrypted entries + digest for AI
   Each saved entry:
     { id, type:'encoded'|'ai'|'system', text: <encoded or plaintext>, summary: <short text for ai ingestion>, timestamp }
   Only summary & ai entries are stored plaintext; sensitive full text is stored encoded.
   -------------------------- */

function appendLogObject(obj){
  const logs = loadLogs();
  logs.push(obj);
  saveLogs(logs);
  renderLogs();
  // queue for optional push if you use server
  pushQueue.push(obj);

  // Also mirror to in-file repo_data if bridge is present
  try {
    if (window.appendEntryObj && typeof window.appendEntryObj === 'function') {
      // mirror user/ai/log/system entries as their respective types in repo_data
      const mirror = { id: obj.id || (Date.now()+'-'+Math.random().toString(36).slice(2,8)), type: obj.type, timestamp: obj.timestamp || nowIso() };
      if (obj.type === 'encoded') {
        mirror.cipher = obj.text;
        mirror.summary = obj.summary;
      } else {
        mirror.summary = obj.summary || obj.text;
        mirror.text = obj.text;
      }
      window.appendEntryObj(mirror);
    } else if (window.appendLogText && typeof window.appendLogText === 'function') {
      window.appendLogText(obj.type.toUpperCase(), obj.summary || obj.text || '');
    }
  } catch (e) {
    console.warn('mirror to repo_data failed', e);
  }
}

// Secure commit method: uses server-side endpoint (no token in browser)
async function sendToSecureCommit(text) {
    const secret = localStorage.getItem('COMMIT_SECRET') || secretInput.value.trim();
    if (!secret) {
        printToTerminal('‚úò No secret set. Enter secret and Save Secret.');
        return;
    }

    try {
        const result = await CommitClient.send(text);
        if (result.ok) {
            printToTerminal('‚úî logged to GitHub via secure server');
        } else {
            printToTerminal('‚úò server error: ' + (result.error || 'unknown'));
        }
    } catch (err) {
        printToTerminal('‚úò commit error: ' + err.message);
    }
}

async function sendToServer(text) {
// GitHub secure server commit method (RECOMMENDED)
async function sendToGitHubServer(text) {
    if (!window.CommitClient) {
        printToTerminal('‚úò CommitClient not loaded. Check static/js/commit-client.js');
        return;
    }

    const secret = localStorage.getItem('COMMIT_SECRET') || tokenInput.value.trim();
    if (!secret) {
        printToTerminal('‚úò No commit secret set. Enter it and Save Token.');
        return;
    }

    try {
        // Check server health first
        const healthy = await CommitClient.checkHealth();
        if (!healthy) {
            printToTerminal('‚ö† Server may be offline. Attempting commit anyway...');
        }

        // Commit the text
        const result = await CommitClient.commit(text);
        printToTerminal('‚úî logged to GitHub via secure server');
        printToTerminal(`  Commit: ${result.commit.sha.substring(0, 7)}`);
    } catch (err) {
        printToTerminal('‚úò Server commit error: ' + err.message);
        if (err.message.includes('secret')) {
            printToTerminal('  Hint: Check that COMMIT_SECRET matches server .env');
        } else if (err.message.includes('timed out')) {
            printToTerminal('  Hint: Is the server running? (node server/commit-server.js)');
        }
    }
}

// File System Access API method (for Chromium browsers)
async function sendToFS(text) {
    if (!window.showSaveFilePicker && !window.chooseFileSystemEntries) {
        printToTerminal('‚úò File System Access API not available in this browser');
        return;
    }
    try {
        // Try to open existing file or prompt user to pick
        const options = {
            types: [{
                description: 'Text log',
                accept: {'text/plain': ['.txt']}
            }]
        };
        // showSaveFilePicker is modern; chooseFileSystemEntries older
        const handle = await window.showSaveFilePicker ? await window.showSaveFilePicker(options) : await window.chooseFileSystemEntries({type: 'save-file'});
        const writable = await handle.createWritable();
        // Read existing contents if possible (best-effort)
        try {
            const fr = await handle.getFile();
            const txt = await fr.text();
            await writable.write(txt + '\n' + text + '\n');
        } catch (e) {
            await writable.write(text + '\n');
        }
        await writable.close();
        printToTerminal('‚úî written to local file');
    } catch (err) {
        printToTerminal('‚úò FS error: ' + err.message);
    }
async function saveEncryptedEntry(plainText, passphrase){
  const encoded = await encryptText(plainText, passphrase, 200000);
  const summary = createDigest(plainText);
  const entry = { id: Date.now()+'-'+Math.random().toString(36).slice(2,8), type:'encoded', text: encoded, summary, timestamp: nowIso() };
  appendLogObject(entry);
  // also keep an ai entry (digest) for ingestion
  appendLogObject({ id: Date.now()+'-'+Math.random().toString(36).slice(2,8), type:'ai', text: summary, timestamp: nowIso() });
  return entry;
}

function createDigest(text){
  const words = text.split(/\s+/).filter(Boolean);
  return words.slice(0,40).join(' ') + (words.length>40?' ‚Ä¶':'');
}

/* --------------------------
   Rendering & UI wiring
   -------------------------- */

function renderLogs(){
  const logs = loadLogs();
  const aiPanel = document.getElementById('ai-output');
  const encPanel = document.getElementById('encoded-output');
  aiPanel.textContent = '';
  encPanel.textContent = '';
  for(const e of logs){
    const line = `[${e.timestamp}] (${e.type}) ${e.type==='encoded' ? (e.summary ? e.summary : '(encoded)') : e.text}\n\n`;
    if (e.type==='ai' || e.type==='system' || e.type==='user') aiPanel.textContent += line;
    encPanel.textContent += line;
  }
  const posEnabled = document.getElementById('pos-toggle').checked;
  if(posEnabled){
    applyPosColoring(document.getElementById('ai-output'));
    applyPosColoring(document.getElementById('encoded-output'));
  }
  const statusEl = document.getElementById('status');
  if(statusEl) statusEl.textContent = `Saved ${logs.length} entries.`;
}

// apply coloring to a panel element, using posColorizeText on its plain text
function applyPosColoring(el){
  try{
    const text = el.textContent || '';
    el.innerHTML = posColorizeText(text);
  }catch(e){
    el.innerText = el.textContent;
  }
}

/* --------------------------
   Push queue and server push helper (optional)
   -------------------------- */
let pushQueue = [];
async function pushToServer(entries, secret){
  const results = [];
  for(const e of entries){
    try{
      const resp = await fetch('/commit', {
        method:'POST',
        headers: {'Content-Type':'application/json', ...(secret?{'X-Commit-Secret':secret}:{})},
        body: JSON.stringify({ text: `[${e.timestamp}] (${e.type}) ${e.type==='encoded'?e.summary:e.text}` })
      });
      const body = await resp.json().catch(()=>({}));
      if(!resp.ok) throw new Error(body && body.error ? body.error : 'server error');
      results.push({ id:e.id, ok:true, commit: body.commit });
    }catch(err){
      results.push({ id:e.id, ok:false, error: err.message });
    }
  }
  for(const r of results.filter(r=>r.ok)) pushQueue = pushQueue.filter(q => q.id !== r.id);
  return results;
}

/* --------------------------
   Keyboard: Enter submits (no Shift), Shift+Enter newline
   -------------------------- */
document.addEventListener('DOMContentLoaded', () => {
  const inputBox = document.getElementById('input-box');
  const submitBtn = document.getElementById('submit-btn');
  const clearBtn = document.getElementById('clear-input');
  const modeToggle = document.getElementById('mode-toggle');
  const autoEncode = document.getElementById('auto-encode');
  const genPass = document.getElementById('gen-pass');
  const passEl = document.getElementById('passphrase');
  const decryptBtn = document.getElementById('decrypt-btn');
  const copyEncoded = document.getElementById('copy-encoded');
  const posToggle = document.getElementById('pos-toggle');

  renderLogs();

  inputBox.addEventListener('keydown', (ev) => {
    if (ev.key === 'Enter' && !ev.shiftKey){
      ev.preventDefault();
      submitBtn.click();
    }
  });

  submitBtn.addEventListener('click', async () => {
    const text = (inputBox.value || '').trim();
    if (!text){
      const s = document.getElementById('status'); if(s) s.textContent = 'Type something to submit';
      return;
    }
    try{
      if(modeToggle.checked){
        const aiText = await fetchAiResponse(text);
        appendPlainLog('user', text);
        appendPlainLog('ai', aiText);
        applyPosColoring(document.getElementById('ai-output'));
        const s = document.getElementById('status'); if(s) s.textContent = 'AI response appended (stored).';
        if(autoEncode.checked){
          const pass = passEl.value || prompt('Enter passphrase to encrypt AI output (will not be saved):') || '';
          if (!pass){ if(s) s.textContent = 'Auto-encode skipped (no passphrase)'; return; }
          const entry = await saveEncryptedEntry(aiText, pass);
          if(s) s.textContent = 'AI response encrypted & stored.';
          applyPosColoring(document.getElementById('encoded-output'));
        }
      } else {
        const pass = passEl.value || prompt('Enter passphrase to encrypt this message (will not be saved):') || '';
        if (!pass){ const s = document.getElementById('status'); if(s) s.textContent = 'Encryption aborted (no passphrase)'; return; }
        await saveEncryptedEntry(text, pass);
        const s = document.getElementById('status'); if(s) s.textContent = 'Message encrypted & stored (encoded).';
        applyPosColoring(document.getElementById('encoded-output'));
      }
      inputBox.value = '';
    }catch(err){
      const s = document.getElementById('status'); if(s) s.textContent = 'Error: ' + (err.message||err);
    }
  });

  clearBtn.addEventListener('click', () => { inputBox.value=''; const s = document.getElementById('status'); if(s) s.textContent=''; });

  genPass.addEventListener('click', () => {
    const p = (Math.random().toString(36).slice(2,10)+Math.random().toString(36).slice(2,6)).slice(0,24);
    passEl.value = p;
    alert('Generated passphrase (copy and keep it secret):\n\n' + p);
  });

  decryptBtn.addEventListener('click', async () => {
    const pass = passEl.value || prompt('Enter passphrase to retrieve last encoded:') || '';
    if(!pass){ const s = document.getElementById('status'); if(s) s.textContent = 'Decryption aborted (no passphrase)'; return; }
    const logs = loadLogs();
    const last = [...logs].reverse().find(l => l.type==='encoded');
    if(!last){ const s = document.getElementById('status'); if(s) s.textContent = 'No encoded entries to retrieve'; return; }
    try{
      const s = document.getElementById('status'); if(s) s.textContent = 'Decrypting...';
      const decoded = await decryptText(last.text, pass, 200000);
      appendPlainLog('system', 'Retrieved encoded entry');
      appendPlainLog('ai', 'RETRIEVED: ' + decoded);
      applyPosColoring(document.getElementById('ai-output'));
      if(s) s.textContent = 'Retrieved and appended to AI output.';
    }catch(e){
      const s = document.getElementById('status'); if(s) s.textContent = 'Decryption failed: ' + (e.message||e);
    }
  });

  copyEncoded.addEventListener('click', async () => {
    try{
      await navigator.clipboard.writeText(document.getElementById('encoded-output').textContent || '');
      const s = document.getElementById('status'); if(s) s.textContent = 'Encoded panel copied to clipboard.';
    }catch(e){ const s = document.getElementById('status'); if(s) s.textContent = 'Copy failed: ' + (e.message||e); }
  });

  posToggle.addEventListener('change', () => {
    applyPosColoring(document.getElementById('ai-output'));
    applyPosColoring(document.getElementById('encoded-output'));
  });
});

/* --------------------------
   Helper functions used above
   -------------------------- */
function appendPlainLog(type, text){
  const logs = loadLogs();
  logs.push({ id: Date.now()+'-'+Math.random().toString(36).slice(2,8), type, text, timestamp: nowIso() });
  saveLogs(logs);
  renderLogs();
  pushQueue.push({ id: logs[logs.length-1].id, type, text, timestamp: nowIso() });

  // Mirror to embed store if available
  try {
    if (window.appendLogText) window.appendLogText(type.toUpperCase(), text);
    if (window.appendEntryObj) {
      const entry = { id: Date.now()+'-'+Math.random().toString(36).slice(2,8), type: type, text: text, timestamp: nowIso() };
      window.appendEntryObj(entry);
    }
  } catch(e){}
}

// small AI fetch: calls /ai or falls back to a local distillation
async function fetchAiResponse(prompt){
  try{
    const resp = await fetch('/ai',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ prompt })});
    if(!resp.ok) throw new Error('no-ai');
    const j = await resp.json();
    return j.text || JSON.stringify(j);
  }catch(e){
    const words = prompt.split(/\s+/).filter(Boolean);
    const top = words.slice(0,40).join(' ');
    return `Octave distilled context: ${top}${words.length>40?' ‚Ä¶':''}`;
  }
}

/* expose some functions for debugging in console if needed */
window.octave = { loadLogs, saveLogs, encryptText, decryptText, pushQueue, pushToServer };
</script>

<!-- Load integration helpers (bridge + shim + embedded writer + token client + UI wiring)
     These scripts hook your existing in-page logic into the embedded repo store and token system.
     Make sure these files exist in static/js/ on your site. -->
<script src="/static/js/pewpi-bridge.js"></script>
<script src="/static/js/encrypt-shim.js"></script>
<script src="/static/js/embedded-writer.js"></script>
<script src="/static/js/token-client.js"></script>
<script src="/static/js/ui-wiring.js"></script>

<!-- Small runtime patch: ensure main functions mirror to repo_data if bridge is loaded.
     This does not remove or change your existing work ‚Äî it only mirrors logs/entries into repo_data
     so the embedded-writer and token systems keep the in-file canonical copy up-to-date. -->
<script>
(function(){
  // if bridge present, force a rebuild of embedded log immediately
  try {
    if (window.EmbeddedWriter && typeof window.EmbeddedWriter.rebuild === 'function') {
      window.EmbeddedWriter.rebuild();
    }
  } catch(e){}
  // ensure TokenClient recognizes any current wallet stored in repo_data.meta
  try {
    const repo = (document.getElementById('repo_data') && JSON.parse(document.getElementById('repo_data').textContent)) || null;
    if (repo && repo.meta && repo.meta.current_user && window.TokenClient && typeof window.TokenClient.ensureUser === 'function') {
      try { TokenClient.ensureUser(repo.meta.current_user); } catch(e){}
    }
  } catch(e){}
})();
</script>
</script>
<!-- INSERT MODULE SCRIPTS BELOW THIS LINE -->
<script src="static/js/pewpi-bridge.js"></script>
<script src="static/js/encrypt-shim.js"></script>
<script src="static/js/embedded-writer.js"></script>
<script src="static/js/token-client.js"></script>
<script src="static/js/ui-wiring.js"></script>
<script src="helper-octave-extension.js"></script>
<!-- END MODULES -->
</body>
<!-- C13B0_CHAT_WIDGET_BEGIN -->
<style>
  .c13b0-chatfab{position:fixed;right:18px;bottom:18px;z-index:99999;border-radius:999px;padding:12px 14px;font-weight:700;box-shadow:0 10px 30px rgba(0,0,0,.25);cursor:pointer;user-select:none}
  .c13b0-chatpanel{position:fixed;right:18px;bottom:72px;width:min(520px,calc(100vw - 36px));height:min(560px,calc(100vh - 120px));z-index:99999;border-radius:18px;overflow:hidden;box-shadow:0 14px 40px rgba(0,0,0,.35);display:none}
  .c13b0-chathead{padding:10px 12px;font-weight:800;display:flex;align-items:center;justify-content:space-between}
  .c13b0-chatbody{height:calc(100% - 94px);overflow:auto;padding:10px 12px;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:13px}
  .c13b0-chatline{white-space:pre-wrap;margin:8px 0}
  .c13b0-chatbar{display:flex;gap:8px;padding:10px 12px;border-top:1px solid rgba(255,255,255,.10)}
  .c13b0-chatin{flex:1;border-radius:12px;padding:10px 12px;border:1px solid rgba(255,255,255,.12);outline:none}
  .c13b0-chatbtn{border-radius:12px;padding:10px 12px;font-weight:800;border:0;cursor:pointer}
</style>

        const method = methodSelect.value;
        if (method === 'secure-commit') sendToSecureCommit(text);
        if (method === 'github-server') sendToGitHubServer(text);
        else if (method === 'server') sendToServer(text);
        else if (method === 'fs') sendToFS(text);
        else if (method === 'github') sendToGitHub(text);
<div id="c13b0_chat_fab" class="c13b0-chatfab">üß±üí¨üß± CHAT</div>

<div id="c13b0_chat_panel" class="c13b0-chatpanel" role="dialog" aria-label="C13B0 Chat">
  <div class="c13b0-chathead">
    <div>üß±üí¨üß± Repo Terminal</div>
    <div style="display:flex;gap:8px;align-items:center">
      <small id="c13b0_chat_repo" style="opacity:.8">repo: (auto)</small>
      <button id="c13b0_chat_close" class="c13b0-chatbtn">‚úï</button>
    </div>
  </div>
  <div id="c13b0_chat_body" class="c13b0-chatbody"></div>
  <div class="c13b0-chatbar">
    <input id="c13b0_chat_in" class="c13b0-chatin" placeholder="Ask this repo... (returns tokenized answer)" />
    <button id="c13b0_chat_send" class="c13b0-chatbtn">SEND</button>
  </div>
</div>

<script>
(function(){
  // Theme: tries to inherit page colors; keeps your design intact.
  const fab = document.getElementById("c13b0_chat_fab");
  const panel = document.getElementById("c13b0_chat_panel");
  const body = document.getElementById("c13b0_chat_body");
  const input = document.getElementById("c13b0_chat_in");
  const send = document.getElementById("c13b0_chat_send");
  const close = document.getElementById("c13b0_chat_close");
  const repoLabel = document.getElementById("c13b0_chat_repo");

  const repo = (location.pathname.split("/")[1] || "").trim(); // for org pages it‚Äôs the repo root on pages
  repoLabel.textContent = "repo: " + (repo || "(root)");

  // Minimal styling decisions; avoid fighting your CSS
  fab.style.background = "rgba(0,0,0,.82)";
  fab.style.color = "white";
  panel.style.background = "rgba(0,0,0,.90)";
  panel.style.color = "white";
  document.querySelector(".c13b0-chathead").style.borderBottom = "1px solid rgba(255,255,255,.10)";
  input.style.background = "rgba(255,255,255,.06)";
  input.style.color = "white";
  send.style.background = "rgba(255,255,255,.14)";
  send.style.color = "white";
  close.style.background = "rgba(255,255,255,.14)";
  close.style.color = "white";

  function line(txt){
    const div=document.createElement("div");
    div.className="c13b0-chatline";
    div.textContent=txt;
    body.appendChild(div);
    body.scrollTop = body.scrollHeight;
  }

  function open(){ panel.style.display="block"; input.focus(); }
  function shut(){ panel.style.display="none"; }

  fab.addEventListener("click", open);
  close.addEventListener("click", shut);
  window.addEventListener("click",(e)=>{
    if(panel.style.display==="block"){
      // click outside closes
      if(!panel.contains(e.target) && e.target!==fab) shut();
    }
  });

  async function ask(){
    const q=(input.value||"").trim();
    if(!q) return;

    line("> " + q);
    input.value="";

    // Router endpoint (you‚Äôll create it in your router repo)
    // expected response: { ok:true, repo:"x", answer:"...", token:{id:"...", value:"...", type:"..."} }
    try{
      const res = await fetch("/router/ask", {
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body: JSON.stringify({ repo, query:q, t: Date.now() })
      });
      const data = await res.json();
      if(!data || !data.ok){
        line("‚ö†Ô∏è Router error: " + (data && data.error ? data.error : "unknown"));
        return;
      }
      if(data.answer) line(data.answer);
      if(data.token){
        line("üß±üü°üß± TOKEN ‚Üí " + JSON.stringify(data.token));
      } else {
        line("üß±üìçüß± no token returned");
      }
    }catch(err){
      line("‚ö†Ô∏è fetch failed: " + err);
    }
  }

// focus UX
window.addEventListener('load', () => { 
    input.focus();
    // Trigger initial method change to show correct inputs
    methodSelect.dispatchEvent(new Event('change'));
});
terminal.addEventListener('click', () => { input.focus(); });
  send.addEventListener("click", ask);
  input.addEventListener("keydown",(e)=>{ if(e.key==="Enter") ask(); });
})();
</script>
<!-- C13B0_CHAT_WIDGET_END -->
</html>
<!-- C14_TOKEN_PANEL_START -->
<div style="font-family:monospace;background:#0b0f14;color:#e6edf3;padding:16px;margin:16px 0">
  <div style="font-size:2.4em;color:#ffd700;text-align:center">
    üß±üçÑ‚≠ê Token Value: 48
  </div>

  <p style="text-align:center">
    üß± Base &nbsp; üçÑ Growth &nbsp; ‚≠ê Star Power
  </p>

  <form action="https://www.paypal.com/cgi-bin/webscr" method="get" target="_blank">
    <input type="hidden" name="cmd" value="_xclick">
    <input type="hidden" name="business" value="watsonkris61@gmail.com">
    <input type="hidden" name="item_name" value="i Token">
    <input type="hidden" name="amount" value="48">
    <input type="hidden" name="currency_code" value="USD">
    <button style="width:100%;padding:14px;font-size:1em">
      Pay $48 via PayPal
    </button>
  </form>

  <p style="font-size:0.75em;text-align:center;margin-top:10px">
    Repository owner: pewpi-infinity<br/>
    Contact: marvaseater@gmail.com<br/>
    Settlement handled externally via PayPal
  </p>
</div>
<!-- C14_TOKEN_PANEL_END -->


<!-- INDEX_VALUE_START -->
<div class="box">
<h2>üß± Index License Token</h2>
<p><strong>Operator:</strong> Kris Watson</p>
<p><strong>License Value (monotonic):</strong> $112 USD</p>
<p><small>Value increases daily via Infinity Plus + Mongoose growth.</small></p>
<form action="https://www.paypal.com/paypalme/marvaseater@gmail.com/112" method="get" target="_blank">
  <button type="submit">Buy License Token</button>
</form>
<p><small>Token grants right to display/use/operate this index for business. No ownership transfer.</small></p>
<p><small>Contact: 808-342-9974</small></p>
</div>
<!-- INDEX_VALUE_END -->

<!-- C13B0:MAP_VIEWER -->
<section>
  <h3>üß±üîóüß± Infinity Ecosystem</h3>
  <select onchange="location=this.value">
    <!-- populated by bots -->
  </select>
</section>

<!-- C13B0:PAYPAL_BLOCK -->
<section>
  <h3>üß±üí∞üß± Acquire Access License</h3>
  <p>Starting price shown below. Value increases with growth.</p>
  <button>Buy Now (PayPal)</button>
</section>
